
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: string
  email: string
  username: string
  password: string
  createdAt: Date
  role: Role
  updatedAt: Date | null
  phoneNumber: string | null
  firstName: string
  lastName: string
  recoveryPhase: string
  slicesCollected: number
  slicesPurchased: number
  slicesSold: number
  cakeBoxClaimed: number
  totalRewardsEarned: number
  avatar: string | null
  sugar: number
  followedByIDs: string[]
  followingIDs: string[]
}

/**
 * Model Platform
 * 
 */
export type Platform = {
  id: string
  userId: string | null
  link: string
  isPopular: boolean | null
  title: string
}

/**
 * Model Wallet
 * 
 */
export type Wallet = {
  id: string
  type: string
  name: string
  address: string
  userId: string | null
}

/**
 * Model Reward
 * 
 */
export type Reward = {
  id: string
  userId: string
  name: string
  image: string
  smallImage: string
  cost: number
  rarity: RarityEnum
  category: string
  createdAt: Date
  updatedAt: Date | null
  type: RewardEnum
  isCakeBox: boolean
  isOnCakeBox: boolean
  isConfectionary: boolean
  RewardByIDs: string[]
  rewardIDs: string[]
  initial: boolean
}

/**
 * Model Token
 * 
 */
export type Token = {
  id: string
  authToken: string
  refreshToken: string
  userId: string
  createdAt: Date
  updatedAt: Date | null
  isDisabled: boolean
}

/**
 * Model TransactionHystory
 * 
 */
export type TransactionHystory = {
  id: string
  createdAt: Date
  userId: string
  sliceId: string | null
  amount: number | null
  rewardId: string | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const RarityEnum: {
  EXOTIC: 'EXOTIC',
  LEGENDARY: 'LEGENDARY',
  EPIC: 'EPIC',
  SUPERIOR: 'SUPERIOR',
  BASIC: 'BASIC',
  STARTER: 'STARTER',
  SLICE: 'SLICE',
  COMMON: 'COMMON'
};

export type RarityEnum = (typeof RarityEnum)[keyof typeof RarityEnum]


export const RewardEnum: {
  SLICE: 'SLICE',
  CAKEBOX: 'CAKEBOX',
  SUGAR: 'SUGAR'
};

export type RewardEnum = (typeof RewardEnum)[keyof typeof RewardEnum]


export const Role: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  KOL: 'KOL'
};

export type Role = (typeof Role)[keyof typeof Role]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): PrismaPromise<Prisma.JsonObject>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.platform`: Exposes CRUD operations for the **Platform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Platforms
    * const platforms = await prisma.platform.findMany()
    * ```
    */
  get platform(): Prisma.PlatformDelegate<GlobalReject>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<GlobalReject>;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **Reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.reward.findMany()
    * ```
    */
  get reward(): Prisma.RewardDelegate<GlobalReject>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<GlobalReject>;

  /**
   * `prisma.transactionHystory`: Exposes CRUD operations for the **TransactionHystory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionHystories
    * const transactionHystories = await prisma.transactionHystory.findMany()
    * ```
    */
  get transactionHystory(): Prisma.TransactionHystoryDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Extensions
   */
  export type Extension = runtime.Extension 

  /**
   * Prisma Client JS version: 4.5.0
   * Query Engine version: 0362da9eebca54d94c8ef5edd3b2e90af99ba452
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Platform: 'Platform',
    Wallet: 'Wallet',
    Reward: 'Reward',
    Token: 'Token',
    TransactionHystory: 'TransactionHystory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    Token: number
    platforms: number
    rewards: number
    TransactionHystory: number
    followedBy: number
    following: number
    wallets: number
  }

  export type UserCountOutputTypeSelect = {
    Token?: boolean
    platforms?: boolean
    rewards?: boolean
    TransactionHystory?: boolean
    followedBy?: boolean
    following?: boolean
    wallets?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type RewardCountOutputType
   */


  export type RewardCountOutputType = {
    TransactionHystory: number
    RewardBy: number
    Reward: number
  }

  export type RewardCountOutputTypeSelect = {
    TransactionHystory?: boolean
    RewardBy?: boolean
    Reward?: boolean
  }

  export type RewardCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RewardCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RewardCountOutputType
    : S extends undefined
    ? never
    : S extends RewardCountOutputTypeArgs
    ?'include' extends U
    ? RewardCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RewardCountOutputType ? RewardCountOutputType[P] : never
  } 
    : RewardCountOutputType
  : RewardCountOutputType




  // Custom InputTypes

  /**
   * RewardCountOutputType without action
   */
  export type RewardCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RewardCountOutputType
     * 
    **/
    select?: RewardCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    slicesCollected: number | null
    slicesPurchased: number | null
    slicesSold: number | null
    cakeBoxClaimed: number | null
    totalRewardsEarned: number | null
    sugar: number | null
  }

  export type UserSumAggregateOutputType = {
    slicesCollected: number | null
    slicesPurchased: number | null
    slicesSold: number | null
    cakeBoxClaimed: number | null
    totalRewardsEarned: number | null
    sugar: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    createdAt: Date | null
    role: Role | null
    updatedAt: Date | null
    phoneNumber: string | null
    firstName: string | null
    lastName: string | null
    recoveryPhase: string | null
    slicesCollected: number | null
    slicesPurchased: number | null
    slicesSold: number | null
    cakeBoxClaimed: number | null
    totalRewardsEarned: number | null
    avatar: string | null
    sugar: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    createdAt: Date | null
    role: Role | null
    updatedAt: Date | null
    phoneNumber: string | null
    firstName: string | null
    lastName: string | null
    recoveryPhase: string | null
    slicesCollected: number | null
    slicesPurchased: number | null
    slicesSold: number | null
    cakeBoxClaimed: number | null
    totalRewardsEarned: number | null
    avatar: string | null
    sugar: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password: number
    createdAt: number
    role: number
    updatedAt: number
    phoneNumber: number
    firstName: number
    lastName: number
    recoveryPhase: number
    slicesCollected: number
    slicesPurchased: number
    slicesSold: number
    cakeBoxClaimed: number
    totalRewardsEarned: number
    avatar: number
    sugar: number
    followedByIDs: number
    followingIDs: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    slicesCollected?: true
    slicesPurchased?: true
    slicesSold?: true
    cakeBoxClaimed?: true
    totalRewardsEarned?: true
    sugar?: true
  }

  export type UserSumAggregateInputType = {
    slicesCollected?: true
    slicesPurchased?: true
    slicesSold?: true
    cakeBoxClaimed?: true
    totalRewardsEarned?: true
    sugar?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    createdAt?: true
    role?: true
    updatedAt?: true
    phoneNumber?: true
    firstName?: true
    lastName?: true
    recoveryPhase?: true
    slicesCollected?: true
    slicesPurchased?: true
    slicesSold?: true
    cakeBoxClaimed?: true
    totalRewardsEarned?: true
    avatar?: true
    sugar?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    createdAt?: true
    role?: true
    updatedAt?: true
    phoneNumber?: true
    firstName?: true
    lastName?: true
    recoveryPhase?: true
    slicesCollected?: true
    slicesPurchased?: true
    slicesSold?: true
    cakeBoxClaimed?: true
    totalRewardsEarned?: true
    avatar?: true
    sugar?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    createdAt?: true
    role?: true
    updatedAt?: true
    phoneNumber?: true
    firstName?: true
    lastName?: true
    recoveryPhase?: true
    slicesCollected?: true
    slicesPurchased?: true
    slicesSold?: true
    cakeBoxClaimed?: true
    totalRewardsEarned?: true
    avatar?: true
    sugar?: true
    followedByIDs?: true
    followingIDs?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    password: string
    createdAt: Date
    role: Role
    updatedAt: Date | null
    phoneNumber: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    slicesCollected: number
    slicesPurchased: number
    slicesSold: number
    cakeBoxClaimed: number
    totalRewardsEarned: number
    avatar: string | null
    sugar: number
    followedByIDs: string[]
    followingIDs: string[]
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    username?: boolean
    Token?: boolean | TokenFindManyArgs
    password?: boolean
    createdAt?: boolean
    role?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    recoveryPhase?: boolean
    platforms?: boolean | PlatformFindManyArgs
    rewards?: boolean | RewardFindManyArgs
    slicesCollected?: boolean
    slicesPurchased?: boolean
    slicesSold?: boolean
    cakeBoxClaimed?: boolean
    totalRewardsEarned?: boolean
    avatar?: boolean
    sugar?: boolean
    TransactionHystory?: boolean | TransactionHystoryFindManyArgs
    followedBy?: boolean | UserFindManyArgs
    followedByIDs?: boolean
    following?: boolean | UserFindManyArgs
    followingIDs?: boolean
    wallets?: boolean | WalletFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    Token?: boolean | TokenFindManyArgs
    platforms?: boolean | PlatformFindManyArgs
    rewards?: boolean | RewardFindManyArgs
    TransactionHystory?: boolean | TransactionHystoryFindManyArgs
    followedBy?: boolean | UserFindManyArgs
    following?: boolean | UserFindManyArgs
    wallets?: boolean | WalletFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Token' ? Array < TokenGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'platforms' ? Array < PlatformGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'rewards' ? Array < RewardGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'TransactionHystory' ? Array < TransactionHystoryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'followedBy' ? Array < UserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'following' ? Array < UserGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'wallets' ? Array < WalletGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Token' ? Array < TokenGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'platforms' ? Array < PlatformGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'rewards' ? Array < RewardGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'TransactionHystory' ? Array < TransactionHystoryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'followedBy' ? Array < UserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'following' ? Array < UserGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'wallets' ? Array < WalletGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null, null>, Prisma__UserClient<UserGetPayload<T> | null, null>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UserFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UserAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Token<T extends TokenFindManyArgs = {}>(args?: Subset<T, TokenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Token>| Null>, PrismaPromise<Array<TokenGetPayload<T>>| Null>>;

    platforms<T extends PlatformFindManyArgs = {}>(args?: Subset<T, PlatformFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Platform>| Null>, PrismaPromise<Array<PlatformGetPayload<T>>| Null>>;

    rewards<T extends RewardFindManyArgs = {}>(args?: Subset<T, RewardFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reward>| Null>, PrismaPromise<Array<RewardGetPayload<T>>| Null>>;

    TransactionHystory<T extends TransactionHystoryFindManyArgs = {}>(args?: Subset<T, TransactionHystoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TransactionHystory>| Null>, PrismaPromise<Array<TransactionHystoryGetPayload<T>>| Null>>;

    followedBy<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>| Null>, PrismaPromise<Array<UserGetPayload<T>>| Null>>;

    following<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>| Null>, PrismaPromise<Array<UserGetPayload<T>>| Null>>;

    wallets<T extends WalletFindManyArgs = {}>(args?: Subset<T, WalletFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Wallet>| Null>, PrismaPromise<Array<WalletGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User findRaw
   */
  export type UserFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Platform
   */


  export type AggregatePlatform = {
    _count: PlatformCountAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  export type PlatformMinAggregateOutputType = {
    id: string | null
    userId: string | null
    link: string | null
    isPopular: boolean | null
    title: string | null
  }

  export type PlatformMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    link: string | null
    isPopular: boolean | null
    title: string | null
  }

  export type PlatformCountAggregateOutputType = {
    id: number
    userId: number
    link: number
    isPopular: number
    title: number
    _all: number
  }


  export type PlatformMinAggregateInputType = {
    id?: true
    userId?: true
    link?: true
    isPopular?: true
    title?: true
  }

  export type PlatformMaxAggregateInputType = {
    id?: true
    userId?: true
    link?: true
    isPopular?: true
    title?: true
  }

  export type PlatformCountAggregateInputType = {
    id?: true
    userId?: true
    link?: true
    isPopular?: true
    title?: true
    _all?: true
  }

  export type PlatformAggregateArgs = {
    /**
     * Filter which Platform to aggregate.
     * 
    **/
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     * 
    **/
    orderBy?: Enumerable<PlatformOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Platforms
    **/
    _count?: true | PlatformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformMaxAggregateInputType
  }

  export type GetPlatformAggregateType<T extends PlatformAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatform[P]>
      : GetScalarType<T[P], AggregatePlatform[P]>
  }




  export type PlatformGroupByArgs = {
    where?: PlatformWhereInput
    orderBy?: Enumerable<PlatformOrderByWithAggregationInput>
    by: Array<PlatformScalarFieldEnum>
    having?: PlatformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformCountAggregateInputType | true
    _min?: PlatformMinAggregateInputType
    _max?: PlatformMaxAggregateInputType
  }


  export type PlatformGroupByOutputType = {
    id: string
    userId: string | null
    link: string
    isPopular: boolean | null
    title: string
    _count: PlatformCountAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  type GetPlatformGroupByPayload<T extends PlatformGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlatformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformGroupByOutputType[P]>
        }
      >
    >


  export type PlatformSelect = {
    id?: boolean
    User?: boolean | UserArgs
    userId?: boolean
    link?: boolean
    isPopular?: boolean
    title?: boolean
  }

  export type PlatformInclude = {
    User?: boolean | UserArgs
  }

  export type PlatformGetPayload<
    S extends boolean | null | undefined | PlatformArgs,
    U = keyof S
      > = S extends true
        ? Platform
    : S extends undefined
    ? never
    : S extends PlatformArgs | PlatformFindManyArgs
    ?'include' extends U
    ? Platform  & {
    [P in TrueKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Platform ? Platform[P] : never
  } 
    : Platform
  : Platform


  type PlatformCountArgs = Merge<
    Omit<PlatformFindManyArgs, 'select' | 'include'> & {
      select?: PlatformCountAggregateInputType | true
    }
  >

  export interface PlatformDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Platform that matches the filter.
     * @param {PlatformFindUniqueArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlatformFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlatformFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Platform'> extends True ? CheckSelect<T, Prisma__PlatformClient<Platform>, Prisma__PlatformClient<PlatformGetPayload<T>>> : CheckSelect<T, Prisma__PlatformClient<Platform | null, null>, Prisma__PlatformClient<PlatformGetPayload<T> | null, null>>

    /**
     * Find the first Platform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlatformFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlatformFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Platform'> extends True ? CheckSelect<T, Prisma__PlatformClient<Platform>, Prisma__PlatformClient<PlatformGetPayload<T>>> : CheckSelect<T, Prisma__PlatformClient<Platform | null, null>, Prisma__PlatformClient<PlatformGetPayload<T> | null, null>>

    /**
     * Find zero or more Platforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Platforms
     * const platforms = await prisma.platform.findMany()
     * 
     * // Get first 10 Platforms
     * const platforms = await prisma.platform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformWithIdOnly = await prisma.platform.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlatformFindManyArgs>(
      args?: SelectSubset<T, PlatformFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Platform>>, PrismaPromise<Array<PlatformGetPayload<T>>>>

    /**
     * Create a Platform.
     * @param {PlatformCreateArgs} args - Arguments to create a Platform.
     * @example
     * // Create one Platform
     * const Platform = await prisma.platform.create({
     *   data: {
     *     // ... data to create a Platform
     *   }
     * })
     * 
    **/
    create<T extends PlatformCreateArgs>(
      args: SelectSubset<T, PlatformCreateArgs>
    ): CheckSelect<T, Prisma__PlatformClient<Platform>, Prisma__PlatformClient<PlatformGetPayload<T>>>

    /**
     * Create many Platforms.
     *     @param {PlatformCreateManyArgs} args - Arguments to create many Platforms.
     *     @example
     *     // Create many Platforms
     *     const platform = await prisma.platform.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlatformCreateManyArgs>(
      args?: SelectSubset<T, PlatformCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Platform.
     * @param {PlatformDeleteArgs} args - Arguments to delete one Platform.
     * @example
     * // Delete one Platform
     * const Platform = await prisma.platform.delete({
     *   where: {
     *     // ... filter to delete one Platform
     *   }
     * })
     * 
    **/
    delete<T extends PlatformDeleteArgs>(
      args: SelectSubset<T, PlatformDeleteArgs>
    ): CheckSelect<T, Prisma__PlatformClient<Platform>, Prisma__PlatformClient<PlatformGetPayload<T>>>

    /**
     * Update one Platform.
     * @param {PlatformUpdateArgs} args - Arguments to update one Platform.
     * @example
     * // Update one Platform
     * const platform = await prisma.platform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlatformUpdateArgs>(
      args: SelectSubset<T, PlatformUpdateArgs>
    ): CheckSelect<T, Prisma__PlatformClient<Platform>, Prisma__PlatformClient<PlatformGetPayload<T>>>

    /**
     * Delete zero or more Platforms.
     * @param {PlatformDeleteManyArgs} args - Arguments to filter Platforms to delete.
     * @example
     * // Delete a few Platforms
     * const { count } = await prisma.platform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlatformDeleteManyArgs>(
      args?: SelectSubset<T, PlatformDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlatformUpdateManyArgs>(
      args: SelectSubset<T, PlatformUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Platform.
     * @param {PlatformUpsertArgs} args - Arguments to update or create a Platform.
     * @example
     * // Update or create a Platform
     * const platform = await prisma.platform.upsert({
     *   create: {
     *     // ... data to create a Platform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Platform we want to update
     *   }
     * })
    **/
    upsert<T extends PlatformUpsertArgs>(
      args: SelectSubset<T, PlatformUpsertArgs>
    ): CheckSelect<T, Prisma__PlatformClient<Platform>, Prisma__PlatformClient<PlatformGetPayload<T>>>

    /**
     * Find zero or more Platforms that matches the filter.
     * @param {PlatformFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const platform = await prisma.platform.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PlatformFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Platform.
     * @param {PlatformAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const platform = await prisma.platform.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PlatformAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Platform that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PlatformFindUniqueOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlatformFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PlatformFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PlatformClient<Platform>, Prisma__PlatformClient<PlatformGetPayload<T>>>

    /**
     * Find the first Platform that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlatformFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PlatformFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PlatformClient<Platform>, Prisma__PlatformClient<PlatformGetPayload<T>>>

    /**
     * Count the number of Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformCountArgs} args - Arguments to filter Platforms to count.
     * @example
     * // Count the number of Platforms
     * const count = await prisma.platform.count({
     *   where: {
     *     // ... the filter for the Platforms we want to count
     *   }
     * })
    **/
    count<T extends PlatformCountArgs>(
      args?: Subset<T, PlatformCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformAggregateArgs>(args: Subset<T, PlatformAggregateArgs>): PrismaPromise<GetPlatformAggregateType<T>>

    /**
     * Group by Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformGroupByArgs['orderBy'] }
        : { orderBy?: PlatformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Platform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlatformClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Platform base type for findUnique actions
   */
  export type PlatformFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Platform
     * 
    **/
    select?: PlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlatformInclude | null
    /**
     * Filter, which Platform to fetch.
     * 
    **/
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform: findUnique
   */
  export interface PlatformFindUniqueArgs extends PlatformFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Platform base type for findFirst actions
   */
  export type PlatformFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Platform
     * 
    **/
    select?: PlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlatformInclude | null
    /**
     * Filter, which Platform to fetch.
     * 
    **/
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     * 
    **/
    orderBy?: Enumerable<PlatformOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Platforms.
     * 
    **/
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Platforms.
     * 
    **/
    distinct?: Enumerable<PlatformScalarFieldEnum>
  }

  /**
   * Platform: findFirst
   */
  export interface PlatformFindFirstArgs extends PlatformFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Platform findMany
   */
  export type PlatformFindManyArgs = {
    /**
     * Select specific fields to fetch from the Platform
     * 
    **/
    select?: PlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlatformInclude | null
    /**
     * Filter, which Platforms to fetch.
     * 
    **/
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     * 
    **/
    orderBy?: Enumerable<PlatformOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Platforms.
     * 
    **/
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlatformScalarFieldEnum>
  }


  /**
   * Platform create
   */
  export type PlatformCreateArgs = {
    /**
     * Select specific fields to fetch from the Platform
     * 
    **/
    select?: PlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlatformInclude | null
    /**
     * The data needed to create a Platform.
     * 
    **/
    data: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
  }


  /**
   * Platform createMany
   */
  export type PlatformCreateManyArgs = {
    /**
     * The data used to create many Platforms.
     * 
    **/
    data: Enumerable<PlatformCreateManyInput>
  }


  /**
   * Platform update
   */
  export type PlatformUpdateArgs = {
    /**
     * Select specific fields to fetch from the Platform
     * 
    **/
    select?: PlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlatformInclude | null
    /**
     * The data needed to update a Platform.
     * 
    **/
    data: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
    /**
     * Choose, which Platform to update.
     * 
    **/
    where: PlatformWhereUniqueInput
  }


  /**
   * Platform updateMany
   */
  export type PlatformUpdateManyArgs = {
    /**
     * The data used to update Platforms.
     * 
    **/
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyInput>
    /**
     * Filter which Platforms to update
     * 
    **/
    where?: PlatformWhereInput
  }


  /**
   * Platform upsert
   */
  export type PlatformUpsertArgs = {
    /**
     * Select specific fields to fetch from the Platform
     * 
    **/
    select?: PlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlatformInclude | null
    /**
     * The filter to search for the Platform to update in case it exists.
     * 
    **/
    where: PlatformWhereUniqueInput
    /**
     * In case the Platform found by the `where` argument doesn't exist, create a new Platform with this data.
     * 
    **/
    create: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
    /**
     * In case the Platform was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
  }


  /**
   * Platform delete
   */
  export type PlatformDeleteArgs = {
    /**
     * Select specific fields to fetch from the Platform
     * 
    **/
    select?: PlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlatformInclude | null
    /**
     * Filter which Platform to delete.
     * 
    **/
    where: PlatformWhereUniqueInput
  }


  /**
   * Platform deleteMany
   */
  export type PlatformDeleteManyArgs = {
    /**
     * Filter which Platforms to delete
     * 
    **/
    where?: PlatformWhereInput
  }


  /**
   * Platform findRaw
   */
  export type PlatformFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Platform aggregateRaw
   */
  export type PlatformAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Platform: findUniqueOrThrow
   */
  export type PlatformFindUniqueOrThrowArgs = PlatformFindUniqueArgsBase
      

  /**
   * Platform: findFirstOrThrow
   */
  export type PlatformFindFirstOrThrowArgs = PlatformFindFirstArgsBase
      

  /**
   * Platform without action
   */
  export type PlatformArgs = {
    /**
     * Select specific fields to fetch from the Platform
     * 
    **/
    select?: PlatformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PlatformInclude | null
  }



  /**
   * Model Wallet
   */


  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    address: string | null
    userId: string | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    address: string | null
    userId: string | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    type: number
    name: number
    address: number
    userId: number
    _all: number
  }


  export type WalletMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    address?: true
    userId?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    address?: true
    userId?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    address?: true
    userId?: true
    _all?: true
  }

  export type WalletAggregateArgs = {
    /**
     * Filter which Wallet to aggregate.
     * 
    **/
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<WalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs = {
    where?: WalletWhereInput
    orderBy?: Enumerable<WalletOrderByWithAggregationInput>
    by: Array<WalletScalarFieldEnum>
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }


  export type WalletGroupByOutputType = {
    id: string
    type: string
    name: string
    address: string
    userId: string | null
    _count: WalletCountAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect = {
    id?: boolean
    type?: boolean
    name?: boolean
    address?: boolean
    User?: boolean | UserArgs
    userId?: boolean
  }

  export type WalletInclude = {
    User?: boolean | UserArgs
  }

  export type WalletGetPayload<
    S extends boolean | null | undefined | WalletArgs,
    U = keyof S
      > = S extends true
        ? Wallet
    : S extends undefined
    ? never
    : S extends WalletArgs | WalletFindManyArgs
    ?'include' extends U
    ? Wallet  & {
    [P in TrueKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof Wallet ? Wallet[P] : never
  } 
    : Wallet
  : Wallet


  type WalletCountArgs = Merge<
    Omit<WalletFindManyArgs, 'select' | 'include'> & {
      select?: WalletCountAggregateInputType | true
    }
  >

  export interface WalletDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WalletFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WalletFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Wallet'> extends True ? CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>> : CheckSelect<T, Prisma__WalletClient<Wallet | null, null>, Prisma__WalletClient<WalletGetPayload<T> | null, null>>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WalletFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WalletFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Wallet'> extends True ? CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>> : CheckSelect<T, Prisma__WalletClient<Wallet | null, null>, Prisma__WalletClient<WalletGetPayload<T> | null, null>>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WalletFindManyArgs>(
      args?: SelectSubset<T, WalletFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Wallet>>, PrismaPromise<Array<WalletGetPayload<T>>>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
    **/
    create<T extends WalletCreateArgs>(
      args: SelectSubset<T, WalletCreateArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Create many Wallets.
     *     @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     *     @example
     *     // Create many Wallets
     *     const wallet = await prisma.wallet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WalletCreateManyArgs>(
      args?: SelectSubset<T, WalletCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
    **/
    delete<T extends WalletDeleteArgs>(
      args: SelectSubset<T, WalletDeleteArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WalletUpdateArgs>(
      args: SelectSubset<T, WalletUpdateArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WalletDeleteManyArgs>(
      args?: SelectSubset<T, WalletDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WalletUpdateManyArgs>(
      args: SelectSubset<T, WalletUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
    **/
    upsert<T extends WalletUpsertArgs>(
      args: SelectSubset<T, WalletUpsertArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Find zero or more Wallets that matches the filter.
     * @param {WalletFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const wallet = await prisma.wallet.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: WalletFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Wallet.
     * @param {WalletAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const wallet = await prisma.wallet.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: WalletAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Wallet that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WalletFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Find the first Wallet that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WalletFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__WalletClient<Wallet>, Prisma__WalletClient<WalletGetPayload<T>>>

    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WalletClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Wallet base type for findUnique actions
   */
  export type WalletFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Filter, which Wallet to fetch.
     * 
    **/
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet: findUnique
   */
  export interface WalletFindUniqueArgs extends WalletFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Wallet base type for findFirst actions
   */
  export type WalletFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Filter, which Wallet to fetch.
     * 
    **/
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<WalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     * 
    **/
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     * 
    **/
    distinct?: Enumerable<WalletScalarFieldEnum>
  }

  /**
   * Wallet: findFirst
   */
  export interface WalletFindFirstArgs extends WalletFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Filter, which Wallets to fetch.
     * 
    **/
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     * 
    **/
    orderBy?: Enumerable<WalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     * 
    **/
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WalletScalarFieldEnum>
  }


  /**
   * Wallet create
   */
  export type WalletCreateArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * The data needed to create a Wallet.
     * 
    **/
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }


  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs = {
    /**
     * The data used to create many Wallets.
     * 
    **/
    data: Enumerable<WalletCreateManyInput>
  }


  /**
   * Wallet update
   */
  export type WalletUpdateArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * The data needed to update a Wallet.
     * 
    **/
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     * 
    **/
    where: WalletWhereUniqueInput
  }


  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs = {
    /**
     * The data used to update Wallets.
     * 
    **/
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     * 
    **/
    where?: WalletWhereInput
  }


  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     * 
    **/
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     * 
    **/
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }


  /**
   * Wallet delete
   */
  export type WalletDeleteArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
    /**
     * Filter which Wallet to delete.
     * 
    **/
    where: WalletWhereUniqueInput
  }


  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs = {
    /**
     * Filter which Wallets to delete
     * 
    **/
    where?: WalletWhereInput
  }


  /**
   * Wallet findRaw
   */
  export type WalletFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Wallet aggregateRaw
   */
  export type WalletAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Wallet: findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs = WalletFindUniqueArgsBase
      

  /**
   * Wallet: findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs = WalletFindFirstArgsBase
      

  /**
   * Wallet without action
   */
  export type WalletArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     * 
    **/
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WalletInclude | null
  }



  /**
   * Model Reward
   */


  export type AggregateReward = {
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  export type RewardAvgAggregateOutputType = {
    cost: number | null
  }

  export type RewardSumAggregateOutputType = {
    cost: number | null
  }

  export type RewardMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    image: string | null
    smallImage: string | null
    cost: number | null
    rarity: RarityEnum | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: RewardEnum | null
    isCakeBox: boolean | null
    isOnCakeBox: boolean | null
    isConfectionary: boolean | null
    initial: boolean | null
  }

  export type RewardMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    image: string | null
    smallImage: string | null
    cost: number | null
    rarity: RarityEnum | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: RewardEnum | null
    isCakeBox: boolean | null
    isOnCakeBox: boolean | null
    isConfectionary: boolean | null
    initial: boolean | null
  }

  export type RewardCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    image: number
    smallImage: number
    cost: number
    rarity: number
    category: number
    createdAt: number
    updatedAt: number
    type: number
    isCakeBox: number
    isOnCakeBox: number
    isConfectionary: number
    RewardByIDs: number
    rewardIDs: number
    initial: number
    _all: number
  }


  export type RewardAvgAggregateInputType = {
    cost?: true
  }

  export type RewardSumAggregateInputType = {
    cost?: true
  }

  export type RewardMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    image?: true
    smallImage?: true
    cost?: true
    rarity?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    isCakeBox?: true
    isOnCakeBox?: true
    isConfectionary?: true
    initial?: true
  }

  export type RewardMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    image?: true
    smallImage?: true
    cost?: true
    rarity?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    isCakeBox?: true
    isOnCakeBox?: true
    isConfectionary?: true
    initial?: true
  }

  export type RewardCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    image?: true
    smallImage?: true
    cost?: true
    rarity?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    isCakeBox?: true
    isOnCakeBox?: true
    isConfectionary?: true
    RewardByIDs?: true
    rewardIDs?: true
    initial?: true
    _all?: true
  }

  export type RewardAggregateArgs = {
    /**
     * Filter which Reward to aggregate.
     * 
    **/
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     * 
    **/
    orderBy?: Enumerable<RewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rewards
    **/
    _count?: true | RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardMaxAggregateInputType
  }

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
        [P in keyof T & keyof AggregateReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>
  }




  export type RewardGroupByArgs = {
    where?: RewardWhereInput
    orderBy?: Enumerable<RewardOrderByWithAggregationInput>
    by: Array<RewardScalarFieldEnum>
    having?: RewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardCountAggregateInputType | true
    _avg?: RewardAvgAggregateInputType
    _sum?: RewardSumAggregateInputType
    _min?: RewardMinAggregateInputType
    _max?: RewardMaxAggregateInputType
  }


  export type RewardGroupByOutputType = {
    id: string
    userId: string
    name: string
    image: string
    smallImage: string
    cost: number
    rarity: RarityEnum
    category: string
    createdAt: Date
    updatedAt: Date | null
    type: RewardEnum
    isCakeBox: boolean
    isOnCakeBox: boolean
    isConfectionary: boolean
    RewardByIDs: string[]
    rewardIDs: string[]
    initial: boolean
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  type GetRewardGroupByPayload<T extends RewardGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardGroupByOutputType[P]>
            : GetScalarType<T[P], RewardGroupByOutputType[P]>
        }
      >
    >


  export type RewardSelect = {
    id?: boolean
    User?: boolean | UserArgs
    userId?: boolean
    name?: boolean
    image?: boolean
    smallImage?: boolean
    cost?: boolean
    rarity?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    TransactionHystory?: boolean | TransactionHystoryFindManyArgs
    RewardBy?: boolean | RewardFindManyArgs
    RewardByIDs?: boolean
    Reward?: boolean | RewardFindManyArgs
    rewardIDs?: boolean
    initial?: boolean
    _count?: boolean | RewardCountOutputTypeArgs
  }

  export type RewardInclude = {
    User?: boolean | UserArgs
    TransactionHystory?: boolean | TransactionHystoryFindManyArgs
    RewardBy?: boolean | RewardFindManyArgs
    Reward?: boolean | RewardFindManyArgs
    _count?: boolean | RewardCountOutputTypeArgs
  }

  export type RewardGetPayload<
    S extends boolean | null | undefined | RewardArgs,
    U = keyof S
      > = S extends true
        ? Reward
    : S extends undefined
    ? never
    : S extends RewardArgs | RewardFindManyArgs
    ?'include' extends U
    ? Reward  & {
    [P in TrueKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'TransactionHystory' ? Array < TransactionHystoryGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'RewardBy' ? Array < RewardGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Reward' ? Array < RewardGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? RewardCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'TransactionHystory' ? Array < TransactionHystoryGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'RewardBy' ? Array < RewardGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Reward' ? Array < RewardGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? RewardCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Reward ? Reward[P] : never
  } 
    : Reward
  : Reward


  type RewardCountArgs = Merge<
    Omit<RewardFindManyArgs, 'select' | 'include'> & {
      select?: RewardCountAggregateInputType | true
    }
  >

  export interface RewardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reward that matches the filter.
     * @param {RewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RewardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RewardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Reward'> extends True ? CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>> : CheckSelect<T, Prisma__RewardClient<Reward | null, null>, Prisma__RewardClient<RewardGetPayload<T> | null, null>>

    /**
     * Find the first Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RewardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RewardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Reward'> extends True ? CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>> : CheckSelect<T, Prisma__RewardClient<Reward | null, null>, Prisma__RewardClient<RewardGetPayload<T> | null, null>>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardWithIdOnly = await prisma.reward.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RewardFindManyArgs>(
      args?: SelectSubset<T, RewardFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Reward>>, PrismaPromise<Array<RewardGetPayload<T>>>>

    /**
     * Create a Reward.
     * @param {RewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     * 
    **/
    create<T extends RewardCreateArgs>(
      args: SelectSubset<T, RewardCreateArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>>

    /**
     * Create many Rewards.
     *     @param {RewardCreateManyArgs} args - Arguments to create many Rewards.
     *     @example
     *     // Create many Rewards
     *     const reward = await prisma.reward.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RewardCreateManyArgs>(
      args?: SelectSubset<T, RewardCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reward.
     * @param {RewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     * 
    **/
    delete<T extends RewardDeleteArgs>(
      args: SelectSubset<T, RewardDeleteArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>>

    /**
     * Update one Reward.
     * @param {RewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RewardUpdateArgs>(
      args: SelectSubset<T, RewardUpdateArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>>

    /**
     * Delete zero or more Rewards.
     * @param {RewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RewardDeleteManyArgs>(
      args?: SelectSubset<T, RewardDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RewardUpdateManyArgs>(
      args: SelectSubset<T, RewardUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reward.
     * @param {RewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
    **/
    upsert<T extends RewardUpsertArgs>(
      args: SelectSubset<T, RewardUpsertArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>>

    /**
     * Find zero or more Rewards that matches the filter.
     * @param {RewardFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const reward = await prisma.reward.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: RewardFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Reward.
     * @param {RewardAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const reward = await prisma.reward.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: RewardAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Reward that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {RewardFindUniqueOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RewardFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RewardFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>>

    /**
     * Find the first Reward that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardFindFirstOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RewardFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RewardFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__RewardClient<Reward>, Prisma__RewardClient<RewardGetPayload<T>>>

    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends RewardCountArgs>(
      args?: Subset<T, RewardCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAggregateArgs>(args: Subset<T, RewardAggregateArgs>): PrismaPromise<GetRewardAggregateType<T>>

    /**
     * Group by Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardGroupByArgs['orderBy'] }
        : { orderBy?: RewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RewardClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    TransactionHystory<T extends TransactionHystoryFindManyArgs = {}>(args?: Subset<T, TransactionHystoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TransactionHystory>| Null>, PrismaPromise<Array<TransactionHystoryGetPayload<T>>| Null>>;

    RewardBy<T extends RewardFindManyArgs = {}>(args?: Subset<T, RewardFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reward>| Null>, PrismaPromise<Array<RewardGetPayload<T>>| Null>>;

    Reward<T extends RewardFindManyArgs = {}>(args?: Subset<T, RewardFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Reward>| Null>, PrismaPromise<Array<RewardGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Reward base type for findUnique actions
   */
  export type RewardFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Reward
     * 
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RewardInclude | null
    /**
     * Filter, which Reward to fetch.
     * 
    **/
    where: RewardWhereUniqueInput
  }

  /**
   * Reward: findUnique
   */
  export interface RewardFindUniqueArgs extends RewardFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reward base type for findFirst actions
   */
  export type RewardFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Reward
     * 
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RewardInclude | null
    /**
     * Filter, which Reward to fetch.
     * 
    **/
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     * 
    **/
    orderBy?: Enumerable<RewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     * 
    **/
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     * 
    **/
    distinct?: Enumerable<RewardScalarFieldEnum>
  }

  /**
   * Reward: findFirst
   */
  export interface RewardFindFirstArgs extends RewardFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reward findMany
   */
  export type RewardFindManyArgs = {
    /**
     * Select specific fields to fetch from the Reward
     * 
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RewardInclude | null
    /**
     * Filter, which Rewards to fetch.
     * 
    **/
    where?: RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     * 
    **/
    orderBy?: Enumerable<RewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rewards.
     * 
    **/
    cursor?: RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RewardScalarFieldEnum>
  }


  /**
   * Reward create
   */
  export type RewardCreateArgs = {
    /**
     * Select specific fields to fetch from the Reward
     * 
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RewardInclude | null
    /**
     * The data needed to create a Reward.
     * 
    **/
    data: XOR<RewardCreateInput, RewardUncheckedCreateInput>
  }


  /**
   * Reward createMany
   */
  export type RewardCreateManyArgs = {
    /**
     * The data used to create many Rewards.
     * 
    **/
    data: Enumerable<RewardCreateManyInput>
  }


  /**
   * Reward update
   */
  export type RewardUpdateArgs = {
    /**
     * Select specific fields to fetch from the Reward
     * 
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RewardInclude | null
    /**
     * The data needed to update a Reward.
     * 
    **/
    data: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
    /**
     * Choose, which Reward to update.
     * 
    **/
    where: RewardWhereUniqueInput
  }


  /**
   * Reward updateMany
   */
  export type RewardUpdateManyArgs = {
    /**
     * The data used to update Rewards.
     * 
    **/
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     * 
    **/
    where?: RewardWhereInput
  }


  /**
   * Reward upsert
   */
  export type RewardUpsertArgs = {
    /**
     * Select specific fields to fetch from the Reward
     * 
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RewardInclude | null
    /**
     * The filter to search for the Reward to update in case it exists.
     * 
    **/
    where: RewardWhereUniqueInput
    /**
     * In case the Reward found by the `where` argument doesn't exist, create a new Reward with this data.
     * 
    **/
    create: XOR<RewardCreateInput, RewardUncheckedCreateInput>
    /**
     * In case the Reward was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RewardUpdateInput, RewardUncheckedUpdateInput>
  }


  /**
   * Reward delete
   */
  export type RewardDeleteArgs = {
    /**
     * Select specific fields to fetch from the Reward
     * 
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RewardInclude | null
    /**
     * Filter which Reward to delete.
     * 
    **/
    where: RewardWhereUniqueInput
  }


  /**
   * Reward deleteMany
   */
  export type RewardDeleteManyArgs = {
    /**
     * Filter which Rewards to delete
     * 
    **/
    where?: RewardWhereInput
  }


  /**
   * Reward findRaw
   */
  export type RewardFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Reward aggregateRaw
   */
  export type RewardAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Reward: findUniqueOrThrow
   */
  export type RewardFindUniqueOrThrowArgs = RewardFindUniqueArgsBase
      

  /**
   * Reward: findFirstOrThrow
   */
  export type RewardFindFirstOrThrowArgs = RewardFindFirstArgsBase
      

  /**
   * Reward without action
   */
  export type RewardArgs = {
    /**
     * Select specific fields to fetch from the Reward
     * 
    **/
    select?: RewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RewardInclude | null
  }



  /**
   * Model Token
   */


  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenMinAggregateOutputType = {
    id: string | null
    authToken: string | null
    refreshToken: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDisabled: boolean | null
  }

  export type TokenMaxAggregateOutputType = {
    id: string | null
    authToken: string | null
    refreshToken: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDisabled: boolean | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    authToken: number
    refreshToken: number
    userId: number
    createdAt: number
    updatedAt: number
    isDisabled: number
    _all: number
  }


  export type TokenMinAggregateInputType = {
    id?: true
    authToken?: true
    refreshToken?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDisabled?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    authToken?: true
    refreshToken?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDisabled?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    authToken?: true
    refreshToken?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    isDisabled?: true
    _all?: true
  }

  export type TokenAggregateArgs = {
    /**
     * Filter which Token to aggregate.
     * 
    **/
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs = {
    where?: TokenWhereInput
    orderBy?: Enumerable<TokenOrderByWithAggregationInput>
    by: Array<TokenScalarFieldEnum>
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }


  export type TokenGroupByOutputType = {
    id: string
    authToken: string
    refreshToken: string
    userId: string
    createdAt: Date
    updatedAt: Date | null
    isDisabled: boolean
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect = {
    id?: boolean
    authToken?: boolean
    refreshToken?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDisabled?: boolean
    user?: boolean | UserArgs
  }

  export type TokenInclude = {
    user?: boolean | UserArgs
  }

  export type TokenGetPayload<
    S extends boolean | null | undefined | TokenArgs,
    U = keyof S
      > = S extends true
        ? Token
    : S extends undefined
    ? never
    : S extends TokenArgs | TokenFindManyArgs
    ?'include' extends U
    ? Token  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Token ? Token[P] : never
  } 
    : Token
  : Token


  type TokenCountArgs = Merge<
    Omit<TokenFindManyArgs, 'select' | 'include'> & {
      select?: TokenCountAggregateInputType | true
    }
  >

  export interface TokenDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Token'> extends True ? CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>> : CheckSelect<T, Prisma__TokenClient<Token | null, null>, Prisma__TokenClient<TokenGetPayload<T> | null, null>>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Token'> extends True ? CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>> : CheckSelect<T, Prisma__TokenClient<Token | null, null>, Prisma__TokenClient<TokenGetPayload<T> | null, null>>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TokenFindManyArgs>(
      args?: SelectSubset<T, TokenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Token>>, PrismaPromise<Array<TokenGetPayload<T>>>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
    **/
    create<T extends TokenCreateArgs>(
      args: SelectSubset<T, TokenCreateArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Create many Tokens.
     *     @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     *     @example
     *     // Create many Tokens
     *     const token = await prisma.token.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TokenCreateManyArgs>(
      args?: SelectSubset<T, TokenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
    **/
    delete<T extends TokenDeleteArgs>(
      args: SelectSubset<T, TokenDeleteArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TokenUpdateArgs>(
      args: SelectSubset<T, TokenUpdateArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TokenDeleteManyArgs>(
      args?: SelectSubset<T, TokenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TokenUpdateManyArgs>(
      args: SelectSubset<T, TokenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
    **/
    upsert<T extends TokenUpsertArgs>(
      args: SelectSubset<T, TokenUpsertArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Find zero or more Tokens that matches the filter.
     * @param {TokenFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const token = await prisma.token.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TokenFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Token.
     * @param {TokenAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const token = await prisma.token.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TokenAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one Token that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TokenFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Find the first Token that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TokenFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TokenClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Token base type for findUnique actions
   */
  export type TokenFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Filter, which Token to fetch.
     * 
    **/
    where: TokenWhereUniqueInput
  }

  /**
   * Token: findUnique
   */
  export interface TokenFindUniqueArgs extends TokenFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Token base type for findFirst actions
   */
  export type TokenFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Filter, which Token to fetch.
     * 
    **/
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     * 
    **/
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     * 
    **/
    distinct?: Enumerable<TokenScalarFieldEnum>
  }

  /**
   * Token: findFirst
   */
  export interface TokenFindFirstArgs extends TokenFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Token findMany
   */
  export type TokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Filter, which Tokens to fetch.
     * 
    **/
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     * 
    **/
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TokenScalarFieldEnum>
  }


  /**
   * Token create
   */
  export type TokenCreateArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * The data needed to create a Token.
     * 
    **/
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }


  /**
   * Token createMany
   */
  export type TokenCreateManyArgs = {
    /**
     * The data used to create many Tokens.
     * 
    **/
    data: Enumerable<TokenCreateManyInput>
  }


  /**
   * Token update
   */
  export type TokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * The data needed to update a Token.
     * 
    **/
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     * 
    **/
    where: TokenWhereUniqueInput
  }


  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs = {
    /**
     * The data used to update Tokens.
     * 
    **/
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     * 
    **/
    where?: TokenWhereInput
  }


  /**
   * Token upsert
   */
  export type TokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * The filter to search for the Token to update in case it exists.
     * 
    **/
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     * 
    **/
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }


  /**
   * Token delete
   */
  export type TokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Filter which Token to delete.
     * 
    **/
    where: TokenWhereUniqueInput
  }


  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs = {
    /**
     * Filter which Tokens to delete
     * 
    **/
    where?: TokenWhereInput
  }


  /**
   * Token findRaw
   */
  export type TokenFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Token aggregateRaw
   */
  export type TokenAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Token: findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs = TokenFindUniqueArgsBase
      

  /**
   * Token: findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs = TokenFindFirstArgsBase
      

  /**
   * Token without action
   */
  export type TokenArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
  }



  /**
   * Model TransactionHystory
   */


  export type AggregateTransactionHystory = {
    _count: TransactionHystoryCountAggregateOutputType | null
    _avg: TransactionHystoryAvgAggregateOutputType | null
    _sum: TransactionHystorySumAggregateOutputType | null
    _min: TransactionHystoryMinAggregateOutputType | null
    _max: TransactionHystoryMaxAggregateOutputType | null
  }

  export type TransactionHystoryAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionHystorySumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionHystoryMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    userId: string | null
    sliceId: string | null
    amount: number | null
    rewardId: string | null
  }

  export type TransactionHystoryMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    userId: string | null
    sliceId: string | null
    amount: number | null
    rewardId: string | null
  }

  export type TransactionHystoryCountAggregateOutputType = {
    id: number
    createdAt: number
    userId: number
    sliceId: number
    amount: number
    rewardId: number
    _all: number
  }


  export type TransactionHystoryAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionHystorySumAggregateInputType = {
    amount?: true
  }

  export type TransactionHystoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    sliceId?: true
    amount?: true
    rewardId?: true
  }

  export type TransactionHystoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    sliceId?: true
    amount?: true
    rewardId?: true
  }

  export type TransactionHystoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    sliceId?: true
    amount?: true
    rewardId?: true
    _all?: true
  }

  export type TransactionHystoryAggregateArgs = {
    /**
     * Filter which TransactionHystory to aggregate.
     * 
    **/
    where?: TransactionHystoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionHystories to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionHystoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TransactionHystoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionHystories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionHystories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionHystories
    **/
    _count?: true | TransactionHystoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionHystoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionHystorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionHystoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionHystoryMaxAggregateInputType
  }

  export type GetTransactionHystoryAggregateType<T extends TransactionHystoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionHystory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionHystory[P]>
      : GetScalarType<T[P], AggregateTransactionHystory[P]>
  }




  export type TransactionHystoryGroupByArgs = {
    where?: TransactionHystoryWhereInput
    orderBy?: Enumerable<TransactionHystoryOrderByWithAggregationInput>
    by: Array<TransactionHystoryScalarFieldEnum>
    having?: TransactionHystoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionHystoryCountAggregateInputType | true
    _avg?: TransactionHystoryAvgAggregateInputType
    _sum?: TransactionHystorySumAggregateInputType
    _min?: TransactionHystoryMinAggregateInputType
    _max?: TransactionHystoryMaxAggregateInputType
  }


  export type TransactionHystoryGroupByOutputType = {
    id: string
    createdAt: Date
    userId: string
    sliceId: string | null
    amount: number | null
    rewardId: string | null
    _count: TransactionHystoryCountAggregateOutputType | null
    _avg: TransactionHystoryAvgAggregateOutputType | null
    _sum: TransactionHystorySumAggregateOutputType | null
    _min: TransactionHystoryMinAggregateOutputType | null
    _max: TransactionHystoryMaxAggregateOutputType | null
  }

  type GetTransactionHystoryGroupByPayload<T extends TransactionHystoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TransactionHystoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionHystoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionHystoryGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionHystoryGroupByOutputType[P]>
        }
      >
    >


  export type TransactionHystorySelect = {
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    sliceId?: boolean
    amount?: boolean
    Reward?: boolean | RewardArgs
    rewardId?: boolean
    User?: boolean | UserArgs
  }

  export type TransactionHystoryInclude = {
    Reward?: boolean | RewardArgs
    User?: boolean | UserArgs
  }

  export type TransactionHystoryGetPayload<
    S extends boolean | null | undefined | TransactionHystoryArgs,
    U = keyof S
      > = S extends true
        ? TransactionHystory
    : S extends undefined
    ? never
    : S extends TransactionHystoryArgs | TransactionHystoryFindManyArgs
    ?'include' extends U
    ? TransactionHystory  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Reward' ? RewardGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'User' ? UserGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Reward' ? RewardGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'User' ? UserGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof TransactionHystory ? TransactionHystory[P] : never
  } 
    : TransactionHystory
  : TransactionHystory


  type TransactionHystoryCountArgs = Merge<
    Omit<TransactionHystoryFindManyArgs, 'select' | 'include'> & {
      select?: TransactionHystoryCountAggregateInputType | true
    }
  >

  export interface TransactionHystoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TransactionHystory that matches the filter.
     * @param {TransactionHystoryFindUniqueArgs} args - Arguments to find a TransactionHystory
     * @example
     * // Get one TransactionHystory
     * const transactionHystory = await prisma.transactionHystory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransactionHystoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TransactionHystoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TransactionHystory'> extends True ? CheckSelect<T, Prisma__TransactionHystoryClient<TransactionHystory>, Prisma__TransactionHystoryClient<TransactionHystoryGetPayload<T>>> : CheckSelect<T, Prisma__TransactionHystoryClient<TransactionHystory | null, null>, Prisma__TransactionHystoryClient<TransactionHystoryGetPayload<T> | null, null>>

    /**
     * Find the first TransactionHystory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHystoryFindFirstArgs} args - Arguments to find a TransactionHystory
     * @example
     * // Get one TransactionHystory
     * const transactionHystory = await prisma.transactionHystory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransactionHystoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TransactionHystoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TransactionHystory'> extends True ? CheckSelect<T, Prisma__TransactionHystoryClient<TransactionHystory>, Prisma__TransactionHystoryClient<TransactionHystoryGetPayload<T>>> : CheckSelect<T, Prisma__TransactionHystoryClient<TransactionHystory | null, null>, Prisma__TransactionHystoryClient<TransactionHystoryGetPayload<T> | null, null>>

    /**
     * Find zero or more TransactionHystories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHystoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionHystories
     * const transactionHystories = await prisma.transactionHystory.findMany()
     * 
     * // Get first 10 TransactionHystories
     * const transactionHystories = await prisma.transactionHystory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionHystoryWithIdOnly = await prisma.transactionHystory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransactionHystoryFindManyArgs>(
      args?: SelectSubset<T, TransactionHystoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TransactionHystory>>, PrismaPromise<Array<TransactionHystoryGetPayload<T>>>>

    /**
     * Create a TransactionHystory.
     * @param {TransactionHystoryCreateArgs} args - Arguments to create a TransactionHystory.
     * @example
     * // Create one TransactionHystory
     * const TransactionHystory = await prisma.transactionHystory.create({
     *   data: {
     *     // ... data to create a TransactionHystory
     *   }
     * })
     * 
    **/
    create<T extends TransactionHystoryCreateArgs>(
      args: SelectSubset<T, TransactionHystoryCreateArgs>
    ): CheckSelect<T, Prisma__TransactionHystoryClient<TransactionHystory>, Prisma__TransactionHystoryClient<TransactionHystoryGetPayload<T>>>

    /**
     * Create many TransactionHystories.
     *     @param {TransactionHystoryCreateManyArgs} args - Arguments to create many TransactionHystories.
     *     @example
     *     // Create many TransactionHystories
     *     const transactionHystory = await prisma.transactionHystory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TransactionHystoryCreateManyArgs>(
      args?: SelectSubset<T, TransactionHystoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TransactionHystory.
     * @param {TransactionHystoryDeleteArgs} args - Arguments to delete one TransactionHystory.
     * @example
     * // Delete one TransactionHystory
     * const TransactionHystory = await prisma.transactionHystory.delete({
     *   where: {
     *     // ... filter to delete one TransactionHystory
     *   }
     * })
     * 
    **/
    delete<T extends TransactionHystoryDeleteArgs>(
      args: SelectSubset<T, TransactionHystoryDeleteArgs>
    ): CheckSelect<T, Prisma__TransactionHystoryClient<TransactionHystory>, Prisma__TransactionHystoryClient<TransactionHystoryGetPayload<T>>>

    /**
     * Update one TransactionHystory.
     * @param {TransactionHystoryUpdateArgs} args - Arguments to update one TransactionHystory.
     * @example
     * // Update one TransactionHystory
     * const transactionHystory = await prisma.transactionHystory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransactionHystoryUpdateArgs>(
      args: SelectSubset<T, TransactionHystoryUpdateArgs>
    ): CheckSelect<T, Prisma__TransactionHystoryClient<TransactionHystory>, Prisma__TransactionHystoryClient<TransactionHystoryGetPayload<T>>>

    /**
     * Delete zero or more TransactionHystories.
     * @param {TransactionHystoryDeleteManyArgs} args - Arguments to filter TransactionHystories to delete.
     * @example
     * // Delete a few TransactionHystories
     * const { count } = await prisma.transactionHystory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransactionHystoryDeleteManyArgs>(
      args?: SelectSubset<T, TransactionHystoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionHystories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHystoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionHystories
     * const transactionHystory = await prisma.transactionHystory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransactionHystoryUpdateManyArgs>(
      args: SelectSubset<T, TransactionHystoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TransactionHystory.
     * @param {TransactionHystoryUpsertArgs} args - Arguments to update or create a TransactionHystory.
     * @example
     * // Update or create a TransactionHystory
     * const transactionHystory = await prisma.transactionHystory.upsert({
     *   create: {
     *     // ... data to create a TransactionHystory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionHystory we want to update
     *   }
     * })
    **/
    upsert<T extends TransactionHystoryUpsertArgs>(
      args: SelectSubset<T, TransactionHystoryUpsertArgs>
    ): CheckSelect<T, Prisma__TransactionHystoryClient<TransactionHystory>, Prisma__TransactionHystoryClient<TransactionHystoryGetPayload<T>>>

    /**
     * Find zero or more TransactionHystories that matches the filter.
     * @param {TransactionHystoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const transactionHystory = await prisma.transactionHystory.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TransactionHystoryFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TransactionHystory.
     * @param {TransactionHystoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const transactionHystory = await prisma.transactionHystory.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TransactionHystoryAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Find one TransactionHystory that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TransactionHystoryFindUniqueOrThrowArgs} args - Arguments to find a TransactionHystory
     * @example
     * // Get one TransactionHystory
     * const transactionHystory = await prisma.transactionHystory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TransactionHystoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TransactionHystoryFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TransactionHystoryClient<TransactionHystory>, Prisma__TransactionHystoryClient<TransactionHystoryGetPayload<T>>>

    /**
     * Find the first TransactionHystory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHystoryFindFirstOrThrowArgs} args - Arguments to find a TransactionHystory
     * @example
     * // Get one TransactionHystory
     * const transactionHystory = await prisma.transactionHystory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TransactionHystoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TransactionHystoryFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TransactionHystoryClient<TransactionHystory>, Prisma__TransactionHystoryClient<TransactionHystoryGetPayload<T>>>

    /**
     * Count the number of TransactionHystories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHystoryCountArgs} args - Arguments to filter TransactionHystories to count.
     * @example
     * // Count the number of TransactionHystories
     * const count = await prisma.transactionHystory.count({
     *   where: {
     *     // ... the filter for the TransactionHystories we want to count
     *   }
     * })
    **/
    count<T extends TransactionHystoryCountArgs>(
      args?: Subset<T, TransactionHystoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionHystoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionHystory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHystoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionHystoryAggregateArgs>(args: Subset<T, TransactionHystoryAggregateArgs>): PrismaPromise<GetTransactionHystoryAggregateType<T>>

    /**
     * Group by TransactionHystory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionHystoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionHystoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionHystoryGroupByArgs['orderBy'] }
        : { orderBy?: TransactionHystoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionHystoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionHystoryGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionHystory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TransactionHystoryClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Reward<T extends RewardArgs = {}>(args?: Subset<T, RewardArgs>): CheckSelect<T, Prisma__RewardClient<Reward | Null>, Prisma__RewardClient<RewardGetPayload<T> | Null>>;

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | Null>, Prisma__UserClient<UserGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TransactionHystory base type for findUnique actions
   */
  export type TransactionHystoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TransactionHystory
     * 
    **/
    select?: TransactionHystorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionHystoryInclude | null
    /**
     * Filter, which TransactionHystory to fetch.
     * 
    **/
    where: TransactionHystoryWhereUniqueInput
  }

  /**
   * TransactionHystory: findUnique
   */
  export interface TransactionHystoryFindUniqueArgs extends TransactionHystoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TransactionHystory base type for findFirst actions
   */
  export type TransactionHystoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TransactionHystory
     * 
    **/
    select?: TransactionHystorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionHystoryInclude | null
    /**
     * Filter, which TransactionHystory to fetch.
     * 
    **/
    where?: TransactionHystoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionHystories to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionHystoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionHystories.
     * 
    **/
    cursor?: TransactionHystoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionHystories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionHystories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionHystories.
     * 
    **/
    distinct?: Enumerable<TransactionHystoryScalarFieldEnum>
  }

  /**
   * TransactionHystory: findFirst
   */
  export interface TransactionHystoryFindFirstArgs extends TransactionHystoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TransactionHystory findMany
   */
  export type TransactionHystoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the TransactionHystory
     * 
    **/
    select?: TransactionHystorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionHystoryInclude | null
    /**
     * Filter, which TransactionHystories to fetch.
     * 
    **/
    where?: TransactionHystoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionHystories to fetch.
     * 
    **/
    orderBy?: Enumerable<TransactionHystoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionHystories.
     * 
    **/
    cursor?: TransactionHystoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionHystories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionHystories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TransactionHystoryScalarFieldEnum>
  }


  /**
   * TransactionHystory create
   */
  export type TransactionHystoryCreateArgs = {
    /**
     * Select specific fields to fetch from the TransactionHystory
     * 
    **/
    select?: TransactionHystorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionHystoryInclude | null
    /**
     * The data needed to create a TransactionHystory.
     * 
    **/
    data: XOR<TransactionHystoryCreateInput, TransactionHystoryUncheckedCreateInput>
  }


  /**
   * TransactionHystory createMany
   */
  export type TransactionHystoryCreateManyArgs = {
    /**
     * The data used to create many TransactionHystories.
     * 
    **/
    data: Enumerable<TransactionHystoryCreateManyInput>
  }


  /**
   * TransactionHystory update
   */
  export type TransactionHystoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the TransactionHystory
     * 
    **/
    select?: TransactionHystorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionHystoryInclude | null
    /**
     * The data needed to update a TransactionHystory.
     * 
    **/
    data: XOR<TransactionHystoryUpdateInput, TransactionHystoryUncheckedUpdateInput>
    /**
     * Choose, which TransactionHystory to update.
     * 
    **/
    where: TransactionHystoryWhereUniqueInput
  }


  /**
   * TransactionHystory updateMany
   */
  export type TransactionHystoryUpdateManyArgs = {
    /**
     * The data used to update TransactionHystories.
     * 
    **/
    data: XOR<TransactionHystoryUpdateManyMutationInput, TransactionHystoryUncheckedUpdateManyInput>
    /**
     * Filter which TransactionHystories to update
     * 
    **/
    where?: TransactionHystoryWhereInput
  }


  /**
   * TransactionHystory upsert
   */
  export type TransactionHystoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the TransactionHystory
     * 
    **/
    select?: TransactionHystorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionHystoryInclude | null
    /**
     * The filter to search for the TransactionHystory to update in case it exists.
     * 
    **/
    where: TransactionHystoryWhereUniqueInput
    /**
     * In case the TransactionHystory found by the `where` argument doesn't exist, create a new TransactionHystory with this data.
     * 
    **/
    create: XOR<TransactionHystoryCreateInput, TransactionHystoryUncheckedCreateInput>
    /**
     * In case the TransactionHystory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TransactionHystoryUpdateInput, TransactionHystoryUncheckedUpdateInput>
  }


  /**
   * TransactionHystory delete
   */
  export type TransactionHystoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the TransactionHystory
     * 
    **/
    select?: TransactionHystorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionHystoryInclude | null
    /**
     * Filter which TransactionHystory to delete.
     * 
    **/
    where: TransactionHystoryWhereUniqueInput
  }


  /**
   * TransactionHystory deleteMany
   */
  export type TransactionHystoryDeleteManyArgs = {
    /**
     * Filter which TransactionHystories to delete
     * 
    **/
    where?: TransactionHystoryWhereInput
  }


  /**
   * TransactionHystory findRaw
   */
  export type TransactionHystoryFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * TransactionHystory aggregateRaw
   */
  export type TransactionHystoryAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * TransactionHystory: findUniqueOrThrow
   */
  export type TransactionHystoryFindUniqueOrThrowArgs = TransactionHystoryFindUniqueArgsBase
      

  /**
   * TransactionHystory: findFirstOrThrow
   */
  export type TransactionHystoryFindFirstOrThrowArgs = TransactionHystoryFindFirstArgsBase
      

  /**
   * TransactionHystory without action
   */
  export type TransactionHystoryArgs = {
    /**
     * Select specific fields to fetch from the TransactionHystory
     * 
    **/
    select?: TransactionHystorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransactionHystoryInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const PlatformScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    link: 'link',
    isPopular: 'isPopular',
    title: 'title'
  };

  export type PlatformScalarFieldEnum = (typeof PlatformScalarFieldEnum)[keyof typeof PlatformScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RewardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    image: 'image',
    smallImage: 'smallImage',
    cost: 'cost',
    rarity: 'rarity',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    type: 'type',
    isCakeBox: 'isCakeBox',
    isOnCakeBox: 'isOnCakeBox',
    isConfectionary: 'isConfectionary',
    RewardByIDs: 'RewardByIDs',
    rewardIDs: 'rewardIDs',
    initial: 'initial'
  };

  export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TokenScalarFieldEnum: {
    id: 'id',
    authToken: 'authToken',
    refreshToken: 'refreshToken',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDisabled: 'isDisabled'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const TransactionHystoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    sliceId: 'sliceId',
    amount: 'amount',
    rewardId: 'rewardId'
  };

  export type TransactionHystoryScalarFieldEnum = (typeof TransactionHystoryScalarFieldEnum)[keyof typeof TransactionHystoryScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password: 'password',
    createdAt: 'createdAt',
    role: 'role',
    updatedAt: 'updatedAt',
    phoneNumber: 'phoneNumber',
    firstName: 'firstName',
    lastName: 'lastName',
    recoveryPhase: 'recoveryPhase',
    slicesCollected: 'slicesCollected',
    slicesPurchased: 'slicesPurchased',
    slicesSold: 'slicesSold',
    cakeBoxClaimed: 'cakeBoxClaimed',
    totalRewardsEarned: 'totalRewardsEarned',
    avatar: 'avatar',
    sugar: 'sugar',
    followedByIDs: 'followedByIDs',
    followingIDs: 'followingIDs'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    address: 'address',
    userId: 'userId'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    username?: StringFilter | string
    Token?: TokenListRelationFilter
    password?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    role?: EnumRoleFilter | Role
    updatedAt?: DateTimeNullableFilter | Date | string | null
    phoneNumber?: StringNullableFilter | string | null
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    recoveryPhase?: StringFilter | string
    platforms?: PlatformListRelationFilter
    rewards?: RewardListRelationFilter
    slicesCollected?: IntFilter | number
    slicesPurchased?: IntFilter | number
    slicesSold?: IntFilter | number
    cakeBoxClaimed?: IntFilter | number
    totalRewardsEarned?: IntFilter | number
    avatar?: StringNullableFilter | string | null
    sugar?: IntFilter | number
    TransactionHystory?: TransactionHystoryListRelationFilter
    followedBy?: UserListRelationFilter
    followedByIDs?: StringNullableListFilter
    following?: UserListRelationFilter
    followingIDs?: StringNullableListFilter
    wallets?: WalletListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    Token?: TokenOrderByRelationAggregateInput
    password?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    recoveryPhase?: SortOrder
    platforms?: PlatformOrderByRelationAggregateInput
    rewards?: RewardOrderByRelationAggregateInput
    slicesCollected?: SortOrder
    slicesPurchased?: SortOrder
    slicesSold?: SortOrder
    cakeBoxClaimed?: SortOrder
    totalRewardsEarned?: SortOrder
    avatar?: SortOrder
    sugar?: SortOrder
    TransactionHystory?: TransactionHystoryOrderByRelationAggregateInput
    followedBy?: UserOrderByRelationAggregateInput
    followedByIDs?: SortOrder
    following?: UserOrderByRelationAggregateInput
    followingIDs?: SortOrder
    wallets?: WalletOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
    username?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    recoveryPhase?: SortOrder
    slicesCollected?: SortOrder
    slicesPurchased?: SortOrder
    slicesSold?: SortOrder
    cakeBoxClaimed?: SortOrder
    totalRewardsEarned?: SortOrder
    avatar?: SortOrder
    sugar?: SortOrder
    followedByIDs?: SortOrder
    followingIDs?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    role?: EnumRoleWithAggregatesFilter | Role
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    recoveryPhase?: StringWithAggregatesFilter | string
    slicesCollected?: IntWithAggregatesFilter | number
    slicesPurchased?: IntWithAggregatesFilter | number
    slicesSold?: IntWithAggregatesFilter | number
    cakeBoxClaimed?: IntWithAggregatesFilter | number
    totalRewardsEarned?: IntWithAggregatesFilter | number
    avatar?: StringNullableWithAggregatesFilter | string | null
    sugar?: IntWithAggregatesFilter | number
    followedByIDs?: StringNullableListFilter
    followingIDs?: StringNullableListFilter
  }

  export type PlatformWhereInput = {
    AND?: Enumerable<PlatformWhereInput>
    OR?: Enumerable<PlatformWhereInput>
    NOT?: Enumerable<PlatformWhereInput>
    id?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
    link?: StringFilter | string
    isPopular?: BoolNullableFilter | boolean | null
    title?: StringFilter | string
  }

  export type PlatformOrderByWithRelationInput = {
    id?: SortOrder
    User?: UserOrderByWithRelationInput
    userId?: SortOrder
    link?: SortOrder
    isPopular?: SortOrder
    title?: SortOrder
  }

  export type PlatformWhereUniqueInput = {
    id?: string
    link?: string
  }

  export type PlatformOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    link?: SortOrder
    isPopular?: SortOrder
    title?: SortOrder
    _count?: PlatformCountOrderByAggregateInput
    _max?: PlatformMaxOrderByAggregateInput
    _min?: PlatformMinOrderByAggregateInput
  }

  export type PlatformScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlatformScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlatformScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlatformScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    link?: StringWithAggregatesFilter | string
    isPopular?: BoolNullableWithAggregatesFilter | boolean | null
    title?: StringWithAggregatesFilter | string
  }

  export type WalletWhereInput = {
    AND?: Enumerable<WalletWhereInput>
    OR?: Enumerable<WalletWhereInput>
    NOT?: Enumerable<WalletWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    name?: StringFilter | string
    address?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    address?: SortOrder
    User?: UserOrderByWithRelationInput
    userId?: SortOrder
  }

  export type WalletWhereUniqueInput = {
    id?: string
    address?: string
  }

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    address?: SortOrder
    userId?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WalletScalarWhereWithAggregatesInput>
    OR?: Enumerable<WalletScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WalletScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type RewardWhereInput = {
    AND?: Enumerable<RewardWhereInput>
    OR?: Enumerable<RewardWhereInput>
    NOT?: Enumerable<RewardWhereInput>
    id?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    name?: StringFilter | string
    image?: StringFilter | string
    smallImage?: StringFilter | string
    cost?: IntFilter | number
    rarity?: EnumRarityEnumFilter | RarityEnum
    category?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    type?: EnumRewardEnumFilter | RewardEnum
    isCakeBox?: BoolFilter | boolean
    isOnCakeBox?: BoolFilter | boolean
    isConfectionary?: BoolFilter | boolean
    TransactionHystory?: TransactionHystoryListRelationFilter
    RewardBy?: RewardListRelationFilter
    RewardByIDs?: StringNullableListFilter
    Reward?: RewardListRelationFilter
    rewardIDs?: StringNullableListFilter
    initial?: BoolFilter | boolean
  }

  export type RewardOrderByWithRelationInput = {
    id?: SortOrder
    User?: UserOrderByWithRelationInput
    userId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    smallImage?: SortOrder
    cost?: SortOrder
    rarity?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    isCakeBox?: SortOrder
    isOnCakeBox?: SortOrder
    isConfectionary?: SortOrder
    TransactionHystory?: TransactionHystoryOrderByRelationAggregateInput
    RewardBy?: RewardOrderByRelationAggregateInput
    RewardByIDs?: SortOrder
    Reward?: RewardOrderByRelationAggregateInput
    rewardIDs?: SortOrder
    initial?: SortOrder
  }

  export type RewardWhereUniqueInput = {
    id?: string
  }

  export type RewardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    smallImage?: SortOrder
    cost?: SortOrder
    rarity?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    isCakeBox?: SortOrder
    isOnCakeBox?: SortOrder
    isConfectionary?: SortOrder
    RewardByIDs?: SortOrder
    rewardIDs?: SortOrder
    initial?: SortOrder
    _count?: RewardCountOrderByAggregateInput
    _avg?: RewardAvgOrderByAggregateInput
    _max?: RewardMaxOrderByAggregateInput
    _min?: RewardMinOrderByAggregateInput
    _sum?: RewardSumOrderByAggregateInput
  }

  export type RewardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RewardScalarWhereWithAggregatesInput>
    OR?: Enumerable<RewardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RewardScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    image?: StringWithAggregatesFilter | string
    smallImage?: StringWithAggregatesFilter | string
    cost?: IntWithAggregatesFilter | number
    rarity?: EnumRarityEnumWithAggregatesFilter | RarityEnum
    category?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    type?: EnumRewardEnumWithAggregatesFilter | RewardEnum
    isCakeBox?: BoolWithAggregatesFilter | boolean
    isOnCakeBox?: BoolWithAggregatesFilter | boolean
    isConfectionary?: BoolWithAggregatesFilter | boolean
    RewardByIDs?: StringNullableListFilter
    rewardIDs?: StringNullableListFilter
    initial?: BoolWithAggregatesFilter | boolean
  }

  export type TokenWhereInput = {
    AND?: Enumerable<TokenWhereInput>
    OR?: Enumerable<TokenWhereInput>
    NOT?: Enumerable<TokenWhereInput>
    id?: StringFilter | string
    authToken?: StringFilter | string
    refreshToken?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    isDisabled?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDisabled?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TokenWhereUniqueInput = {
    id?: string
  }

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDisabled?: SortOrder
    _count?: TokenCountOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<TokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TokenScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    authToken?: StringWithAggregatesFilter | string
    refreshToken?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isDisabled?: BoolWithAggregatesFilter | boolean
  }

  export type TransactionHystoryWhereInput = {
    AND?: Enumerable<TransactionHystoryWhereInput>
    OR?: Enumerable<TransactionHystoryWhereInput>
    NOT?: Enumerable<TransactionHystoryWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    sliceId?: StringNullableFilter | string | null
    amount?: IntNullableFilter | number | null
    Reward?: XOR<RewardRelationFilter, RewardWhereInput> | null
    rewardId?: StringNullableFilter | string | null
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TransactionHystoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    sliceId?: SortOrder
    amount?: SortOrder
    Reward?: RewardOrderByWithRelationInput
    rewardId?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type TransactionHystoryWhereUniqueInput = {
    id?: string
  }

  export type TransactionHystoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    sliceId?: SortOrder
    amount?: SortOrder
    rewardId?: SortOrder
    _count?: TransactionHystoryCountOrderByAggregateInput
    _avg?: TransactionHystoryAvgOrderByAggregateInput
    _max?: TransactionHystoryMaxOrderByAggregateInput
    _min?: TransactionHystoryMinOrderByAggregateInput
    _sum?: TransactionHystorySumOrderByAggregateInput
  }

  export type TransactionHystoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TransactionHystoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<TransactionHystoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TransactionHystoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
    sliceId?: StringNullableWithAggregatesFilter | string | null
    amount?: IntNullableWithAggregatesFilter | number | null
    rewardId?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    Token?: TokenCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryCreateNestedManyWithoutUserInput
    followedBy?: UserCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserUncheckedCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUpdateManyWithoutUserNestedInput
    followedBy?: UserUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserUncheckedUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
  }

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
  }

  export type PlatformCreateInput = {
    id?: string
    User?: UserCreateNestedOneWithoutPlatformsInput
    link: string
    isPopular?: boolean | null
    title: string
  }

  export type PlatformUncheckedCreateInput = {
    id?: string
    userId?: string | null
    link: string
    isPopular?: boolean | null
    title: string
  }

  export type PlatformUpdateInput = {
    User?: UserUpdateOneWithoutPlatformsNestedInput
    link?: StringFieldUpdateOperationsInput | string
    isPopular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformUncheckedUpdateInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    isPopular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformCreateManyInput = {
    id?: string
    userId?: string | null
    link: string
    isPopular?: boolean | null
    title: string
  }

  export type PlatformUpdateManyMutationInput = {
    link?: StringFieldUpdateOperationsInput | string
    isPopular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformUncheckedUpdateManyInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    link?: StringFieldUpdateOperationsInput | string
    isPopular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type WalletCreateInput = {
    id?: string
    type: string
    name: string
    address: string
    User?: UserCreateNestedOneWithoutWalletsInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    type: string
    name: string
    address: string
    userId?: string | null
  }

  export type WalletUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutWalletsNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletCreateManyInput = {
    id?: string
    type: string
    name: string
    address: string
    userId?: string | null
  }

  export type WalletUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type WalletUncheckedUpdateManyInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardCreateInput = {
    id?: string
    User: UserCreateNestedOneWithoutRewardsInput
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    TransactionHystory?: TransactionHystoryCreateNestedManyWithoutRewardInput
    RewardBy?: RewardCreateNestedManyWithoutRewardInput
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    Reward?: RewardCreateNestedManyWithoutRewardByInput
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type RewardUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    TransactionHystory?: TransactionHystoryUncheckedCreateNestedManyWithoutRewardInput
    RewardBy?: RewardUncheckedCreateNestedManyWithoutRewardInput
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUncheckedCreateNestedManyWithoutRewardByInput
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type RewardUpdateInput = {
    User?: UserUpdateOneRequiredWithoutRewardsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    TransactionHystory?: TransactionHystoryUpdateManyWithoutRewardNestedInput
    RewardBy?: RewardUpdateManyWithoutRewardNestedInput
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUpdateManyWithoutRewardByNestedInput
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RewardUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    TransactionHystory?: TransactionHystoryUncheckedUpdateManyWithoutRewardNestedInput
    RewardBy?: RewardUncheckedUpdateManyWithoutRewardNestedInput
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUncheckedUpdateManyWithoutRewardByNestedInput
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RewardCreateManyInput = {
    id?: string
    userId: string
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type RewardUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RewardUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenCreateInput = {
    id?: string
    authToken: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isDisabled?: boolean
    user: UserCreateNestedOneWithoutTokenInput
  }

  export type TokenUncheckedCreateInput = {
    id?: string
    authToken: string
    refreshToken: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isDisabled?: boolean
  }

  export type TokenUpdateInput = {
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenCreateManyInput = {
    id?: string
    authToken: string
    refreshToken: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isDisabled?: boolean
  }

  export type TokenUpdateManyMutationInput = {
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenUncheckedUpdateManyInput = {
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionHystoryCreateInput = {
    id?: string
    createdAt?: Date | string
    sliceId?: string | null
    amount?: number | null
    Reward?: RewardCreateNestedOneWithoutTransactionHystoryInput
    User: UserCreateNestedOneWithoutTransactionHystoryInput
  }

  export type TransactionHystoryUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    sliceId?: string | null
    amount?: number | null
    rewardId?: string | null
  }

  export type TransactionHystoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sliceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    Reward?: RewardUpdateOneWithoutTransactionHystoryNestedInput
    User?: UserUpdateOneRequiredWithoutTransactionHystoryNestedInput
  }

  export type TransactionHystoryUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    sliceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionHystoryCreateManyInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    sliceId?: string | null
    amount?: number | null
    rewardId?: string | null
  }

  export type TransactionHystoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sliceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionHystoryUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    sliceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type PlatformListRelationFilter = {
    every?: PlatformWhereInput
    some?: PlatformWhereInput
    none?: PlatformWhereInput
  }

  export type RewardListRelationFilter = {
    every?: RewardWhereInput
    some?: RewardWhereInput
    none?: RewardWhereInput
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type TransactionHystoryListRelationFilter = {
    every?: TransactionHystoryWhereInput
    some?: TransactionHystoryWhereInput
    none?: TransactionHystoryWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type WalletListRelationFilter = {
    every?: WalletWhereInput
    some?: WalletWhereInput
    none?: WalletWhereInput
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlatformOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionHystoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    recoveryPhase?: SortOrder
    slicesCollected?: SortOrder
    slicesPurchased?: SortOrder
    slicesSold?: SortOrder
    cakeBoxClaimed?: SortOrder
    totalRewardsEarned?: SortOrder
    avatar?: SortOrder
    sugar?: SortOrder
    followedByIDs?: SortOrder
    followingIDs?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    slicesCollected?: SortOrder
    slicesPurchased?: SortOrder
    slicesSold?: SortOrder
    cakeBoxClaimed?: SortOrder
    totalRewardsEarned?: SortOrder
    sugar?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    recoveryPhase?: SortOrder
    slicesCollected?: SortOrder
    slicesPurchased?: SortOrder
    slicesSold?: SortOrder
    cakeBoxClaimed?: SortOrder
    totalRewardsEarned?: SortOrder
    avatar?: SortOrder
    sugar?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    recoveryPhase?: SortOrder
    slicesCollected?: SortOrder
    slicesPurchased?: SortOrder
    slicesSold?: SortOrder
    cakeBoxClaimed?: SortOrder
    totalRewardsEarned?: SortOrder
    avatar?: SortOrder
    sugar?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    slicesCollected?: SortOrder
    slicesPurchased?: SortOrder
    slicesSold?: SortOrder
    cakeBoxClaimed?: SortOrder
    totalRewardsEarned?: SortOrder
    sugar?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
    isSet?: boolean
  }

  export type PlatformCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    link?: SortOrder
    isPopular?: SortOrder
    title?: SortOrder
  }

  export type PlatformMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    link?: SortOrder
    isPopular?: SortOrder
    title?: SortOrder
  }

  export type PlatformMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    link?: SortOrder
    isPopular?: SortOrder
    title?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    isSet?: boolean
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    address?: SortOrder
    userId?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    address?: SortOrder
    userId?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    address?: SortOrder
    userId?: SortOrder
  }

  export type EnumRarityEnumFilter = {
    equals?: RarityEnum
    in?: Enumerable<RarityEnum>
    notIn?: Enumerable<RarityEnum>
    not?: NestedEnumRarityEnumFilter | RarityEnum
  }

  export type EnumRewardEnumFilter = {
    equals?: RewardEnum
    in?: Enumerable<RewardEnum>
    notIn?: Enumerable<RewardEnum>
    not?: NestedEnumRewardEnumFilter | RewardEnum
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type RewardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    smallImage?: SortOrder
    cost?: SortOrder
    rarity?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    isCakeBox?: SortOrder
    isOnCakeBox?: SortOrder
    isConfectionary?: SortOrder
    RewardByIDs?: SortOrder
    rewardIDs?: SortOrder
    initial?: SortOrder
  }

  export type RewardAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type RewardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    smallImage?: SortOrder
    cost?: SortOrder
    rarity?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    isCakeBox?: SortOrder
    isOnCakeBox?: SortOrder
    isConfectionary?: SortOrder
    initial?: SortOrder
  }

  export type RewardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    image?: SortOrder
    smallImage?: SortOrder
    cost?: SortOrder
    rarity?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    isCakeBox?: SortOrder
    isOnCakeBox?: SortOrder
    isConfectionary?: SortOrder
    initial?: SortOrder
  }

  export type RewardSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type EnumRarityEnumWithAggregatesFilter = {
    equals?: RarityEnum
    in?: Enumerable<RarityEnum>
    notIn?: Enumerable<RarityEnum>
    not?: NestedEnumRarityEnumWithAggregatesFilter | RarityEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRarityEnumFilter
    _max?: NestedEnumRarityEnumFilter
  }

  export type EnumRewardEnumWithAggregatesFilter = {
    equals?: RewardEnum
    in?: Enumerable<RewardEnum>
    notIn?: Enumerable<RewardEnum>
    not?: NestedEnumRewardEnumWithAggregatesFilter | RewardEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRewardEnumFilter
    _max?: NestedEnumRewardEnumFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDisabled?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDisabled?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    authToken?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDisabled?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type RewardRelationFilter = {
    is?: RewardWhereInput | null
    isNot?: RewardWhereInput | null
  }

  export type TransactionHystoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    sliceId?: SortOrder
    amount?: SortOrder
    rewardId?: SortOrder
  }

  export type TransactionHystoryAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionHystoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    sliceId?: SortOrder
    amount?: SortOrder
    rewardId?: SortOrder
  }

  export type TransactionHystoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    sliceId?: SortOrder
    amount?: SortOrder
    rewardId?: SortOrder
  }

  export type TransactionHystorySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    isSet?: boolean
  }

  export type TokenCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TokenCreateWithoutUserInput>, Enumerable<TokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutUserInput>
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: Enumerable<TokenWhereUniqueInput>
  }

  export type PlatformCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PlatformCreateWithoutUserInput>, Enumerable<PlatformUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PlatformCreateOrConnectWithoutUserInput>
    createMany?: PlatformCreateManyUserInputEnvelope
    connect?: Enumerable<PlatformWhereUniqueInput>
  }

  export type RewardCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RewardCreateWithoutUserInput>, Enumerable<RewardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutUserInput>
    createMany?: RewardCreateManyUserInputEnvelope
    connect?: Enumerable<RewardWhereUniqueInput>
  }

  export type TransactionHystoryCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionHystoryCreateWithoutUserInput>, Enumerable<TransactionHystoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionHystoryCreateOrConnectWithoutUserInput>
    createMany?: TransactionHystoryCreateManyUserInputEnvelope
    connect?: Enumerable<TransactionHystoryWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutFollowingInput = {
    create?: XOR<Enumerable<UserCreateWithoutFollowingInput>, Enumerable<UserUncheckedCreateWithoutFollowingInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFollowingInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserCreatefollowedByIDsInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedManyWithoutFollowedByInput = {
    create?: XOR<Enumerable<UserCreateWithoutFollowedByInput>, Enumerable<UserUncheckedCreateWithoutFollowedByInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFollowedByInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserCreatefollowingIDsInput = {
    set: Enumerable<string>
  }

  export type WalletCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WalletCreateWithoutUserInput>, Enumerable<WalletUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutUserInput>
    createMany?: WalletCreateManyUserInputEnvelope
    connect?: Enumerable<WalletWhereUniqueInput>
  }

  export type TokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TokenCreateWithoutUserInput>, Enumerable<TokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutUserInput>
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: Enumerable<TokenWhereUniqueInput>
  }

  export type PlatformUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PlatformCreateWithoutUserInput>, Enumerable<PlatformUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PlatformCreateOrConnectWithoutUserInput>
    createMany?: PlatformCreateManyUserInputEnvelope
    connect?: Enumerable<PlatformWhereUniqueInput>
  }

  export type RewardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RewardCreateWithoutUserInput>, Enumerable<RewardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutUserInput>
    createMany?: RewardCreateManyUserInputEnvelope
    connect?: Enumerable<RewardWhereUniqueInput>
  }

  export type TransactionHystoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionHystoryCreateWithoutUserInput>, Enumerable<TransactionHystoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionHystoryCreateOrConnectWithoutUserInput>
    createMany?: TransactionHystoryCreateManyUserInputEnvelope
    connect?: Enumerable<TransactionHystoryWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<Enumerable<UserCreateWithoutFollowingInput>, Enumerable<UserUncheckedCreateWithoutFollowingInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFollowingInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutFollowedByInput = {
    create?: XOR<Enumerable<UserCreateWithoutFollowedByInput>, Enumerable<UserUncheckedCreateWithoutFollowedByInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFollowedByInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type WalletUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WalletCreateWithoutUserInput>, Enumerable<WalletUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutUserInput>
    createMany?: WalletCreateManyUserInputEnvelope
    connect?: Enumerable<WalletWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type TokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TokenCreateWithoutUserInput>, Enumerable<TokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TokenCreateManyUserInputEnvelope
    set?: Enumerable<TokenWhereUniqueInput>
    disconnect?: Enumerable<TokenWhereUniqueInput>
    delete?: Enumerable<TokenWhereUniqueInput>
    connect?: Enumerable<TokenWhereUniqueInput>
    update?: Enumerable<TokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TokenScalarWhereInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type PlatformUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PlatformCreateWithoutUserInput>, Enumerable<PlatformUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PlatformCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PlatformUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PlatformCreateManyUserInputEnvelope
    set?: Enumerable<PlatformWhereUniqueInput>
    disconnect?: Enumerable<PlatformWhereUniqueInput>
    delete?: Enumerable<PlatformWhereUniqueInput>
    connect?: Enumerable<PlatformWhereUniqueInput>
    update?: Enumerable<PlatformUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PlatformUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PlatformScalarWhereInput>
  }

  export type RewardUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RewardCreateWithoutUserInput>, Enumerable<RewardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RewardUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RewardCreateManyUserInputEnvelope
    set?: Enumerable<RewardWhereUniqueInput>
    disconnect?: Enumerable<RewardWhereUniqueInput>
    delete?: Enumerable<RewardWhereUniqueInput>
    connect?: Enumerable<RewardWhereUniqueInput>
    update?: Enumerable<RewardUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RewardUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RewardScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TransactionHystoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TransactionHystoryCreateWithoutUserInput>, Enumerable<TransactionHystoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionHystoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TransactionHystoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TransactionHystoryCreateManyUserInputEnvelope
    set?: Enumerable<TransactionHystoryWhereUniqueInput>
    disconnect?: Enumerable<TransactionHystoryWhereUniqueInput>
    delete?: Enumerable<TransactionHystoryWhereUniqueInput>
    connect?: Enumerable<TransactionHystoryWhereUniqueInput>
    update?: Enumerable<TransactionHystoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TransactionHystoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TransactionHystoryScalarWhereInput>
  }

  export type UserUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutFollowingInput>, Enumerable<UserUncheckedCreateWithoutFollowingInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFollowingInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutFollowingInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutFollowingInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutFollowingInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUpdatefollowedByIDsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUpdateManyWithoutFollowedByNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutFollowedByInput>, Enumerable<UserUncheckedCreateWithoutFollowedByInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFollowedByInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutFollowedByInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutFollowedByInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutFollowedByInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUpdatefollowingIDsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type WalletUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WalletCreateWithoutUserInput>, Enumerable<WalletUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WalletUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WalletCreateManyUserInputEnvelope
    set?: Enumerable<WalletWhereUniqueInput>
    disconnect?: Enumerable<WalletWhereUniqueInput>
    delete?: Enumerable<WalletWhereUniqueInput>
    connect?: Enumerable<WalletWhereUniqueInput>
    update?: Enumerable<WalletUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WalletUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WalletScalarWhereInput>
  }

  export type TokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TokenCreateWithoutUserInput>, Enumerable<TokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TokenCreateManyUserInputEnvelope
    set?: Enumerable<TokenWhereUniqueInput>
    disconnect?: Enumerable<TokenWhereUniqueInput>
    delete?: Enumerable<TokenWhereUniqueInput>
    connect?: Enumerable<TokenWhereUniqueInput>
    update?: Enumerable<TokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TokenScalarWhereInput>
  }

  export type PlatformUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PlatformCreateWithoutUserInput>, Enumerable<PlatformUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PlatformCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PlatformUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PlatformCreateManyUserInputEnvelope
    set?: Enumerable<PlatformWhereUniqueInput>
    disconnect?: Enumerable<PlatformWhereUniqueInput>
    delete?: Enumerable<PlatformWhereUniqueInput>
    connect?: Enumerable<PlatformWhereUniqueInput>
    update?: Enumerable<PlatformUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PlatformUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PlatformScalarWhereInput>
  }

  export type RewardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<RewardCreateWithoutUserInput>, Enumerable<RewardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RewardUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RewardCreateManyUserInputEnvelope
    set?: Enumerable<RewardWhereUniqueInput>
    disconnect?: Enumerable<RewardWhereUniqueInput>
    delete?: Enumerable<RewardWhereUniqueInput>
    connect?: Enumerable<RewardWhereUniqueInput>
    update?: Enumerable<RewardUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RewardUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RewardScalarWhereInput>
  }

  export type TransactionHystoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TransactionHystoryCreateWithoutUserInput>, Enumerable<TransactionHystoryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionHystoryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TransactionHystoryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TransactionHystoryCreateManyUserInputEnvelope
    set?: Enumerable<TransactionHystoryWhereUniqueInput>
    disconnect?: Enumerable<TransactionHystoryWhereUniqueInput>
    delete?: Enumerable<TransactionHystoryWhereUniqueInput>
    connect?: Enumerable<TransactionHystoryWhereUniqueInput>
    update?: Enumerable<TransactionHystoryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TransactionHystoryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TransactionHystoryScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutFollowingInput>, Enumerable<UserUncheckedCreateWithoutFollowingInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFollowingInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutFollowingInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutFollowingInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutFollowingInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutFollowedByNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutFollowedByInput>, Enumerable<UserUncheckedCreateWithoutFollowedByInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFollowedByInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutFollowedByInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutFollowedByInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutFollowedByInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type WalletUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WalletCreateWithoutUserInput>, Enumerable<WalletUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WalletCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WalletUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WalletCreateManyUserInputEnvelope
    set?: Enumerable<WalletWhereUniqueInput>
    disconnect?: Enumerable<WalletWhereUniqueInput>
    delete?: Enumerable<WalletWhereUniqueInput>
    connect?: Enumerable<WalletWhereUniqueInput>
    update?: Enumerable<WalletUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WalletUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WalletScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutPlatformsInput = {
    create?: XOR<UserCreateWithoutPlatformsInput, UserUncheckedCreateWithoutPlatformsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlatformsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutPlatformsNestedInput = {
    create?: XOR<UserCreateWithoutPlatformsInput, UserUncheckedCreateWithoutPlatformsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlatformsInput
    upsert?: UserUpsertWithoutPlatformsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPlatformsInput, UserUncheckedUpdateWithoutPlatformsInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type UserCreateNestedOneWithoutWalletsInput = {
    create?: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutWalletsNestedInput = {
    create?: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletsInput
    upsert?: UserUpsertWithoutWalletsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWalletsInput, UserUncheckedUpdateWithoutWalletsInput>
  }

  export type UserCreateNestedOneWithoutRewardsInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionHystoryCreateNestedManyWithoutRewardInput = {
    create?: XOR<Enumerable<TransactionHystoryCreateWithoutRewardInput>, Enumerable<TransactionHystoryUncheckedCreateWithoutRewardInput>>
    connectOrCreate?: Enumerable<TransactionHystoryCreateOrConnectWithoutRewardInput>
    createMany?: TransactionHystoryCreateManyRewardInputEnvelope
    connect?: Enumerable<TransactionHystoryWhereUniqueInput>
  }

  export type RewardCreateNestedManyWithoutRewardInput = {
    create?: XOR<Enumerable<RewardCreateWithoutRewardInput>, Enumerable<RewardUncheckedCreateWithoutRewardInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutRewardInput>
    connect?: Enumerable<RewardWhereUniqueInput>
  }

  export type RewardCreateRewardByIDsInput = {
    set: Enumerable<string>
  }

  export type RewardCreateNestedManyWithoutRewardByInput = {
    create?: XOR<Enumerable<RewardCreateWithoutRewardByInput>, Enumerable<RewardUncheckedCreateWithoutRewardByInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutRewardByInput>
    connect?: Enumerable<RewardWhereUniqueInput>
  }

  export type RewardCreaterewardIDsInput = {
    set: Enumerable<string>
  }

  export type TransactionHystoryUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<Enumerable<TransactionHystoryCreateWithoutRewardInput>, Enumerable<TransactionHystoryUncheckedCreateWithoutRewardInput>>
    connectOrCreate?: Enumerable<TransactionHystoryCreateOrConnectWithoutRewardInput>
    createMany?: TransactionHystoryCreateManyRewardInputEnvelope
    connect?: Enumerable<TransactionHystoryWhereUniqueInput>
  }

  export type RewardUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<Enumerable<RewardCreateWithoutRewardInput>, Enumerable<RewardUncheckedCreateWithoutRewardInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutRewardInput>
    connect?: Enumerable<RewardWhereUniqueInput>
  }

  export type RewardUncheckedCreateNestedManyWithoutRewardByInput = {
    create?: XOR<Enumerable<RewardCreateWithoutRewardByInput>, Enumerable<RewardUncheckedCreateWithoutRewardByInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutRewardByInput>
    connect?: Enumerable<RewardWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    upsert?: UserUpsertWithoutRewardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
  }

  export type EnumRarityEnumFieldUpdateOperationsInput = {
    set?: RarityEnum
  }

  export type EnumRewardEnumFieldUpdateOperationsInput = {
    set?: RewardEnum
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TransactionHystoryUpdateManyWithoutRewardNestedInput = {
    create?: XOR<Enumerable<TransactionHystoryCreateWithoutRewardInput>, Enumerable<TransactionHystoryUncheckedCreateWithoutRewardInput>>
    connectOrCreate?: Enumerable<TransactionHystoryCreateOrConnectWithoutRewardInput>
    upsert?: Enumerable<TransactionHystoryUpsertWithWhereUniqueWithoutRewardInput>
    createMany?: TransactionHystoryCreateManyRewardInputEnvelope
    set?: Enumerable<TransactionHystoryWhereUniqueInput>
    disconnect?: Enumerable<TransactionHystoryWhereUniqueInput>
    delete?: Enumerable<TransactionHystoryWhereUniqueInput>
    connect?: Enumerable<TransactionHystoryWhereUniqueInput>
    update?: Enumerable<TransactionHystoryUpdateWithWhereUniqueWithoutRewardInput>
    updateMany?: Enumerable<TransactionHystoryUpdateManyWithWhereWithoutRewardInput>
    deleteMany?: Enumerable<TransactionHystoryScalarWhereInput>
  }

  export type RewardUpdateManyWithoutRewardNestedInput = {
    create?: XOR<Enumerable<RewardCreateWithoutRewardInput>, Enumerable<RewardUncheckedCreateWithoutRewardInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutRewardInput>
    upsert?: Enumerable<RewardUpsertWithWhereUniqueWithoutRewardInput>
    set?: Enumerable<RewardWhereUniqueInput>
    disconnect?: Enumerable<RewardWhereUniqueInput>
    delete?: Enumerable<RewardWhereUniqueInput>
    connect?: Enumerable<RewardWhereUniqueInput>
    update?: Enumerable<RewardUpdateWithWhereUniqueWithoutRewardInput>
    updateMany?: Enumerable<RewardUpdateManyWithWhereWithoutRewardInput>
    deleteMany?: Enumerable<RewardScalarWhereInput>
  }

  export type RewardUpdateRewardByIDsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type RewardUpdateManyWithoutRewardByNestedInput = {
    create?: XOR<Enumerable<RewardCreateWithoutRewardByInput>, Enumerable<RewardUncheckedCreateWithoutRewardByInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutRewardByInput>
    upsert?: Enumerable<RewardUpsertWithWhereUniqueWithoutRewardByInput>
    set?: Enumerable<RewardWhereUniqueInput>
    disconnect?: Enumerable<RewardWhereUniqueInput>
    delete?: Enumerable<RewardWhereUniqueInput>
    connect?: Enumerable<RewardWhereUniqueInput>
    update?: Enumerable<RewardUpdateWithWhereUniqueWithoutRewardByInput>
    updateMany?: Enumerable<RewardUpdateManyWithWhereWithoutRewardByInput>
    deleteMany?: Enumerable<RewardScalarWhereInput>
  }

  export type RewardUpdaterewardIDsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type TransactionHystoryUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<Enumerable<TransactionHystoryCreateWithoutRewardInput>, Enumerable<TransactionHystoryUncheckedCreateWithoutRewardInput>>
    connectOrCreate?: Enumerable<TransactionHystoryCreateOrConnectWithoutRewardInput>
    upsert?: Enumerable<TransactionHystoryUpsertWithWhereUniqueWithoutRewardInput>
    createMany?: TransactionHystoryCreateManyRewardInputEnvelope
    set?: Enumerable<TransactionHystoryWhereUniqueInput>
    disconnect?: Enumerable<TransactionHystoryWhereUniqueInput>
    delete?: Enumerable<TransactionHystoryWhereUniqueInput>
    connect?: Enumerable<TransactionHystoryWhereUniqueInput>
    update?: Enumerable<TransactionHystoryUpdateWithWhereUniqueWithoutRewardInput>
    updateMany?: Enumerable<TransactionHystoryUpdateManyWithWhereWithoutRewardInput>
    deleteMany?: Enumerable<TransactionHystoryScalarWhereInput>
  }

  export type RewardUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<Enumerable<RewardCreateWithoutRewardInput>, Enumerable<RewardUncheckedCreateWithoutRewardInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutRewardInput>
    upsert?: Enumerable<RewardUpsertWithWhereUniqueWithoutRewardInput>
    set?: Enumerable<RewardWhereUniqueInput>
    disconnect?: Enumerable<RewardWhereUniqueInput>
    delete?: Enumerable<RewardWhereUniqueInput>
    connect?: Enumerable<RewardWhereUniqueInput>
    update?: Enumerable<RewardUpdateWithWhereUniqueWithoutRewardInput>
    updateMany?: Enumerable<RewardUpdateManyWithWhereWithoutRewardInput>
    deleteMany?: Enumerable<RewardScalarWhereInput>
  }

  export type RewardUncheckedUpdateManyWithoutRewardByNestedInput = {
    create?: XOR<Enumerable<RewardCreateWithoutRewardByInput>, Enumerable<RewardUncheckedCreateWithoutRewardByInput>>
    connectOrCreate?: Enumerable<RewardCreateOrConnectWithoutRewardByInput>
    upsert?: Enumerable<RewardUpsertWithWhereUniqueWithoutRewardByInput>
    set?: Enumerable<RewardWhereUniqueInput>
    disconnect?: Enumerable<RewardWhereUniqueInput>
    delete?: Enumerable<RewardWhereUniqueInput>
    connect?: Enumerable<RewardWhereUniqueInput>
    update?: Enumerable<RewardUpdateWithWhereUniqueWithoutRewardByInput>
    updateMany?: Enumerable<RewardUpdateManyWithWhereWithoutRewardByInput>
    deleteMany?: Enumerable<RewardScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutTokenInput = {
    create?: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTokenNestedInput = {
    create?: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenInput
    upsert?: UserUpsertWithoutTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTokenInput, UserUncheckedUpdateWithoutTokenInput>
  }

  export type RewardCreateNestedOneWithoutTransactionHystoryInput = {
    create?: XOR<RewardCreateWithoutTransactionHystoryInput, RewardUncheckedCreateWithoutTransactionHystoryInput>
    connectOrCreate?: RewardCreateOrConnectWithoutTransactionHystoryInput
    connect?: RewardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionHystoryInput = {
    create?: XOR<UserCreateWithoutTransactionHystoryInput, UserUncheckedCreateWithoutTransactionHystoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionHystoryInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type RewardUpdateOneWithoutTransactionHystoryNestedInput = {
    create?: XOR<RewardCreateWithoutTransactionHystoryInput, RewardUncheckedCreateWithoutTransactionHystoryInput>
    connectOrCreate?: RewardCreateOrConnectWithoutTransactionHystoryInput
    upsert?: RewardUpsertWithoutTransactionHystoryInput
    disconnect?: boolean
    delete?: boolean
    connect?: RewardWhereUniqueInput
    update?: XOR<RewardUpdateWithoutTransactionHystoryInput, RewardUncheckedUpdateWithoutTransactionHystoryInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionHystoryNestedInput = {
    create?: XOR<UserCreateWithoutTransactionHystoryInput, UserUncheckedCreateWithoutTransactionHystoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionHystoryInput
    upsert?: UserUpsertWithoutTransactionHystoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTransactionHystoryInput, UserUncheckedUpdateWithoutTransactionHystoryInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    isSet?: boolean
  }

  export type NestedEnumRarityEnumFilter = {
    equals?: RarityEnum
    in?: Enumerable<RarityEnum>
    notIn?: Enumerable<RarityEnum>
    not?: NestedEnumRarityEnumFilter | RarityEnum
  }

  export type NestedEnumRewardEnumFilter = {
    equals?: RewardEnum
    in?: Enumerable<RewardEnum>
    notIn?: Enumerable<RewardEnum>
    not?: NestedEnumRewardEnumFilter | RewardEnum
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumRarityEnumWithAggregatesFilter = {
    equals?: RarityEnum
    in?: Enumerable<RarityEnum>
    notIn?: Enumerable<RarityEnum>
    not?: NestedEnumRarityEnumWithAggregatesFilter | RarityEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRarityEnumFilter
    _max?: NestedEnumRarityEnumFilter
  }

  export type NestedEnumRewardEnumWithAggregatesFilter = {
    equals?: RewardEnum
    in?: Enumerable<RewardEnum>
    notIn?: Enumerable<RewardEnum>
    not?: NestedEnumRewardEnumWithAggregatesFilter | RewardEnum
    _count?: NestedIntFilter
    _min?: NestedEnumRewardEnumFilter
    _max?: NestedEnumRewardEnumFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    isSet?: boolean
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type TokenCreateWithoutUserInput = {
    id?: string
    authToken: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isDisabled?: boolean
  }

  export type TokenUncheckedCreateWithoutUserInput = {
    id?: string
    authToken: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isDisabled?: boolean
  }

  export type TokenCreateOrConnectWithoutUserInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenCreateManyUserInputEnvelope = {
    data: Enumerable<TokenCreateManyUserInput>
  }

  export type PlatformCreateWithoutUserInput = {
    id?: string
    link: string
    isPopular?: boolean | null
    title: string
  }

  export type PlatformUncheckedCreateWithoutUserInput = {
    id?: string
    link: string
    isPopular?: boolean | null
    title: string
  }

  export type PlatformCreateOrConnectWithoutUserInput = {
    where: PlatformWhereUniqueInput
    create: XOR<PlatformCreateWithoutUserInput, PlatformUncheckedCreateWithoutUserInput>
  }

  export type PlatformCreateManyUserInputEnvelope = {
    data: Enumerable<PlatformCreateManyUserInput>
  }

  export type RewardCreateWithoutUserInput = {
    id?: string
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    TransactionHystory?: TransactionHystoryCreateNestedManyWithoutRewardInput
    RewardBy?: RewardCreateNestedManyWithoutRewardInput
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    Reward?: RewardCreateNestedManyWithoutRewardByInput
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type RewardUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    TransactionHystory?: TransactionHystoryUncheckedCreateNestedManyWithoutRewardInput
    RewardBy?: RewardUncheckedCreateNestedManyWithoutRewardInput
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUncheckedCreateNestedManyWithoutRewardByInput
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type RewardCreateOrConnectWithoutUserInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput>
  }

  export type RewardCreateManyUserInputEnvelope = {
    data: Enumerable<RewardCreateManyUserInput>
  }

  export type TransactionHystoryCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    sliceId?: string | null
    amount?: number | null
    Reward?: RewardCreateNestedOneWithoutTransactionHystoryInput
  }

  export type TransactionHystoryUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    sliceId?: string | null
    amount?: number | null
    rewardId?: string | null
  }

  export type TransactionHystoryCreateOrConnectWithoutUserInput = {
    where: TransactionHystoryWhereUniqueInput
    create: XOR<TransactionHystoryCreateWithoutUserInput, TransactionHystoryUncheckedCreateWithoutUserInput>
  }

  export type TransactionHystoryCreateManyUserInputEnvelope = {
    data: Enumerable<TransactionHystoryCreateManyUserInput>
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    email: string
    username: string
    Token?: TokenCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryCreateNestedManyWithoutUserInput
    followedBy?: UserCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    email: string
    username: string
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserUncheckedCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserCreateWithoutFollowedByInput = {
    id?: string
    email: string
    username: string
    Token?: TokenCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryCreateNestedManyWithoutUserInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowedByInput = {
    id?: string
    email: string
    username: string
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryUncheckedCreateNestedManyWithoutUserInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    type: string
    name: string
    address: string
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    name: string
    address: string
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WalletCreateManyUserInputEnvelope = {
    data: Enumerable<WalletCreateManyUserInput>
  }

  export type TokenUpsertWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
  }

  export type TokenUpdateManyWithWhereWithoutUserInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutTokenInput>
  }

  export type TokenScalarWhereInput = {
    AND?: Enumerable<TokenScalarWhereInput>
    OR?: Enumerable<TokenScalarWhereInput>
    NOT?: Enumerable<TokenScalarWhereInput>
    id?: StringFilter | string
    authToken?: StringFilter | string
    refreshToken?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    isDisabled?: BoolFilter | boolean
  }

  export type PlatformUpsertWithWhereUniqueWithoutUserInput = {
    where: PlatformWhereUniqueInput
    update: XOR<PlatformUpdateWithoutUserInput, PlatformUncheckedUpdateWithoutUserInput>
    create: XOR<PlatformCreateWithoutUserInput, PlatformUncheckedCreateWithoutUserInput>
  }

  export type PlatformUpdateWithWhereUniqueWithoutUserInput = {
    where: PlatformWhereUniqueInput
    data: XOR<PlatformUpdateWithoutUserInput, PlatformUncheckedUpdateWithoutUserInput>
  }

  export type PlatformUpdateManyWithWhereWithoutUserInput = {
    where: PlatformScalarWhereInput
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyWithoutPlatformsInput>
  }

  export type PlatformScalarWhereInput = {
    AND?: Enumerable<PlatformScalarWhereInput>
    OR?: Enumerable<PlatformScalarWhereInput>
    NOT?: Enumerable<PlatformScalarWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    link?: StringFilter | string
    isPopular?: BoolNullableFilter | boolean | null
    title?: StringFilter | string
  }

  export type RewardUpsertWithWhereUniqueWithoutUserInput = {
    where: RewardWhereUniqueInput
    update: XOR<RewardUpdateWithoutUserInput, RewardUncheckedUpdateWithoutUserInput>
    create: XOR<RewardCreateWithoutUserInput, RewardUncheckedCreateWithoutUserInput>
  }

  export type RewardUpdateWithWhereUniqueWithoutUserInput = {
    where: RewardWhereUniqueInput
    data: XOR<RewardUpdateWithoutUserInput, RewardUncheckedUpdateWithoutUserInput>
  }

  export type RewardUpdateManyWithWhereWithoutUserInput = {
    where: RewardScalarWhereInput
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyWithoutRewardsInput>
  }

  export type RewardScalarWhereInput = {
    AND?: Enumerable<RewardScalarWhereInput>
    OR?: Enumerable<RewardScalarWhereInput>
    NOT?: Enumerable<RewardScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    name?: StringFilter | string
    image?: StringFilter | string
    smallImage?: StringFilter | string
    cost?: IntFilter | number
    rarity?: EnumRarityEnumFilter | RarityEnum
    category?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    type?: EnumRewardEnumFilter | RewardEnum
    isCakeBox?: BoolFilter | boolean
    isOnCakeBox?: BoolFilter | boolean
    isConfectionary?: BoolFilter | boolean
    RewardByIDs?: StringNullableListFilter
    rewardIDs?: StringNullableListFilter
    initial?: BoolFilter | boolean
  }

  export type TransactionHystoryUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionHystoryWhereUniqueInput
    update: XOR<TransactionHystoryUpdateWithoutUserInput, TransactionHystoryUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionHystoryCreateWithoutUserInput, TransactionHystoryUncheckedCreateWithoutUserInput>
  }

  export type TransactionHystoryUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionHystoryWhereUniqueInput
    data: XOR<TransactionHystoryUpdateWithoutUserInput, TransactionHystoryUncheckedUpdateWithoutUserInput>
  }

  export type TransactionHystoryUpdateManyWithWhereWithoutUserInput = {
    where: TransactionHystoryScalarWhereInput
    data: XOR<TransactionHystoryUpdateManyMutationInput, TransactionHystoryUncheckedUpdateManyWithoutTransactionHystoryInput>
  }

  export type TransactionHystoryScalarWhereInput = {
    AND?: Enumerable<TransactionHystoryScalarWhereInput>
    OR?: Enumerable<TransactionHystoryScalarWhereInput>
    NOT?: Enumerable<TransactionHystoryScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    sliceId?: StringNullableFilter | string | null
    amount?: IntNullableFilter | number | null
    rewardId?: StringNullableFilter | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutFollowingInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserUpdateWithWhereUniqueWithoutFollowingInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateManyWithWhereWithoutFollowingInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutFollowedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    username?: StringFilter | string
    password?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    role?: EnumRoleFilter | Role
    updatedAt?: DateTimeNullableFilter | Date | string | null
    phoneNumber?: StringNullableFilter | string | null
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    recoveryPhase?: StringFilter | string
    slicesCollected?: IntFilter | number
    slicesPurchased?: IntFilter | number
    slicesSold?: IntFilter | number
    cakeBoxClaimed?: IntFilter | number
    totalRewardsEarned?: IntFilter | number
    avatar?: StringNullableFilter | string | null
    sugar?: IntFilter | number
    followedByIDs?: StringNullableListFilter
    followingIDs?: StringNullableListFilter
  }

  export type UserUpsertWithWhereUniqueWithoutFollowedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutFollowedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
  }

  export type UserUpdateManyWithWhereWithoutFollowedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutFollowingInput>
  }

  export type WalletUpsertWithWhereUniqueWithoutUserInput = {
    where: WalletWhereUniqueInput
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WalletUpdateWithWhereUniqueWithoutUserInput = {
    where: WalletWhereUniqueInput
    data: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateManyWithWhereWithoutUserInput = {
    where: WalletScalarWhereInput
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyWithoutWalletsInput>
  }

  export type WalletScalarWhereInput = {
    AND?: Enumerable<WalletScalarWhereInput>
    OR?: Enumerable<WalletScalarWhereInput>
    NOT?: Enumerable<WalletScalarWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    name?: StringFilter | string
    address?: StringFilter | string
    userId?: StringNullableFilter | string | null
  }

  export type UserCreateWithoutPlatformsInput = {
    id?: string
    email: string
    username: string
    Token?: TokenCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    rewards?: RewardCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryCreateNestedManyWithoutUserInput
    followedBy?: UserCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlatformsInput = {
    id?: string
    email: string
    username: string
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserUncheckedCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlatformsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlatformsInput, UserUncheckedCreateWithoutPlatformsInput>
  }

  export type UserUpsertWithoutPlatformsInput = {
    update: XOR<UserUpdateWithoutPlatformsInput, UserUncheckedUpdateWithoutPlatformsInput>
    create: XOR<UserCreateWithoutPlatformsInput, UserUncheckedCreateWithoutPlatformsInput>
  }

  export type UserUpdateWithoutPlatformsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    rewards?: RewardUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUpdateManyWithoutUserNestedInput
    followedBy?: UserUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlatformsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserUncheckedUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWalletsInput = {
    id?: string
    email: string
    username: string
    Token?: TokenCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryCreateNestedManyWithoutUserInput
    followedBy?: UserCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
  }

  export type UserUncheckedCreateWithoutWalletsInput = {
    id?: string
    email: string
    username: string
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserUncheckedCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
  }

  export type UserCreateOrConnectWithoutWalletsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
  }

  export type UserUpsertWithoutWalletsInput = {
    update: XOR<UserUpdateWithoutWalletsInput, UserUncheckedUpdateWithoutWalletsInput>
    create: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
  }

  export type UserUpdateWithoutWalletsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUpdateManyWithoutUserNestedInput
    followedBy?: UserUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
  }

  export type UserUncheckedUpdateWithoutWalletsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserUncheckedUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
  }

  export type UserCreateWithoutRewardsInput = {
    id?: string
    email: string
    username: string
    Token?: TokenCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryCreateNestedManyWithoutUserInput
    followedBy?: UserCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRewardsInput = {
    id?: string
    email: string
    username: string
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformUncheckedCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserUncheckedCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRewardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
  }

  export type TransactionHystoryCreateWithoutRewardInput = {
    id?: string
    createdAt?: Date | string
    sliceId?: string | null
    amount?: number | null
    User: UserCreateNestedOneWithoutTransactionHystoryInput
  }

  export type TransactionHystoryUncheckedCreateWithoutRewardInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    sliceId?: string | null
    amount?: number | null
  }

  export type TransactionHystoryCreateOrConnectWithoutRewardInput = {
    where: TransactionHystoryWhereUniqueInput
    create: XOR<TransactionHystoryCreateWithoutRewardInput, TransactionHystoryUncheckedCreateWithoutRewardInput>
  }

  export type TransactionHystoryCreateManyRewardInputEnvelope = {
    data: Enumerable<TransactionHystoryCreateManyRewardInput>
  }

  export type RewardCreateWithoutRewardInput = {
    id?: string
    User: UserCreateNestedOneWithoutRewardsInput
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    TransactionHystory?: TransactionHystoryCreateNestedManyWithoutRewardInput
    RewardBy?: RewardCreateNestedManyWithoutRewardInput
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type RewardUncheckedCreateWithoutRewardInput = {
    id?: string
    userId: string
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    TransactionHystory?: TransactionHystoryUncheckedCreateNestedManyWithoutRewardInput
    RewardBy?: RewardUncheckedCreateNestedManyWithoutRewardInput
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type RewardCreateOrConnectWithoutRewardInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutRewardInput, RewardUncheckedCreateWithoutRewardInput>
  }

  export type RewardCreateWithoutRewardByInput = {
    id?: string
    User: UserCreateNestedOneWithoutRewardsInput
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    TransactionHystory?: TransactionHystoryCreateNestedManyWithoutRewardInput
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    Reward?: RewardCreateNestedManyWithoutRewardByInput
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type RewardUncheckedCreateWithoutRewardByInput = {
    id?: string
    userId: string
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    TransactionHystory?: TransactionHystoryUncheckedCreateNestedManyWithoutRewardInput
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUncheckedCreateNestedManyWithoutRewardByInput
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type RewardCreateOrConnectWithoutRewardByInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutRewardByInput, RewardUncheckedCreateWithoutRewardByInput>
  }

  export type UserUpsertWithoutRewardsInput = {
    update: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
  }

  export type UserUpdateWithoutRewardsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUpdateManyWithoutUserNestedInput
    followedBy?: UserUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRewardsInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUncheckedUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserUncheckedUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionHystoryUpsertWithWhereUniqueWithoutRewardInput = {
    where: TransactionHystoryWhereUniqueInput
    update: XOR<TransactionHystoryUpdateWithoutRewardInput, TransactionHystoryUncheckedUpdateWithoutRewardInput>
    create: XOR<TransactionHystoryCreateWithoutRewardInput, TransactionHystoryUncheckedCreateWithoutRewardInput>
  }

  export type TransactionHystoryUpdateWithWhereUniqueWithoutRewardInput = {
    where: TransactionHystoryWhereUniqueInput
    data: XOR<TransactionHystoryUpdateWithoutRewardInput, TransactionHystoryUncheckedUpdateWithoutRewardInput>
  }

  export type TransactionHystoryUpdateManyWithWhereWithoutRewardInput = {
    where: TransactionHystoryScalarWhereInput
    data: XOR<TransactionHystoryUpdateManyMutationInput, TransactionHystoryUncheckedUpdateManyWithoutTransactionHystoryInput>
  }

  export type RewardUpsertWithWhereUniqueWithoutRewardInput = {
    where: RewardWhereUniqueInput
    update: XOR<RewardUpdateWithoutRewardInput, RewardUncheckedUpdateWithoutRewardInput>
    create: XOR<RewardCreateWithoutRewardInput, RewardUncheckedCreateWithoutRewardInput>
  }

  export type RewardUpdateWithWhereUniqueWithoutRewardInput = {
    where: RewardWhereUniqueInput
    data: XOR<RewardUpdateWithoutRewardInput, RewardUncheckedUpdateWithoutRewardInput>
  }

  export type RewardUpdateManyWithWhereWithoutRewardInput = {
    where: RewardScalarWhereInput
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyWithoutRewardByInput>
  }

  export type RewardUpsertWithWhereUniqueWithoutRewardByInput = {
    where: RewardWhereUniqueInput
    update: XOR<RewardUpdateWithoutRewardByInput, RewardUncheckedUpdateWithoutRewardByInput>
    create: XOR<RewardCreateWithoutRewardByInput, RewardUncheckedCreateWithoutRewardByInput>
  }

  export type RewardUpdateWithWhereUniqueWithoutRewardByInput = {
    where: RewardWhereUniqueInput
    data: XOR<RewardUpdateWithoutRewardByInput, RewardUncheckedUpdateWithoutRewardByInput>
  }

  export type RewardUpdateManyWithWhereWithoutRewardByInput = {
    where: RewardScalarWhereInput
    data: XOR<RewardUpdateManyMutationInput, RewardUncheckedUpdateManyWithoutRewardInput>
  }

  export type UserCreateWithoutTokenInput = {
    id?: string
    email: string
    username: string
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryCreateNestedManyWithoutUserInput
    followedBy?: UserCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTokenInput = {
    id?: string
    email: string
    username: string
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    TransactionHystory?: TransactionHystoryUncheckedCreateNestedManyWithoutUserInput
    followedBy?: UserUncheckedCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
  }

  export type UserUpsertWithoutTokenInput = {
    update: XOR<UserUpdateWithoutTokenInput, UserUncheckedUpdateWithoutTokenInput>
    create: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
  }

  export type UserUpdateWithoutTokenInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUpdateManyWithoutUserNestedInput
    followedBy?: UserUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokenInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserUncheckedUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RewardCreateWithoutTransactionHystoryInput = {
    id?: string
    User: UserCreateNestedOneWithoutRewardsInput
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    RewardBy?: RewardCreateNestedManyWithoutRewardInput
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    Reward?: RewardCreateNestedManyWithoutRewardByInput
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type RewardUncheckedCreateWithoutTransactionHystoryInput = {
    id?: string
    userId: string
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    RewardBy?: RewardUncheckedCreateNestedManyWithoutRewardInput
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUncheckedCreateNestedManyWithoutRewardByInput
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type RewardCreateOrConnectWithoutTransactionHystoryInput = {
    where: RewardWhereUniqueInput
    create: XOR<RewardCreateWithoutTransactionHystoryInput, RewardUncheckedCreateWithoutTransactionHystoryInput>
  }

  export type UserCreateWithoutTransactionHystoryInput = {
    id?: string
    email: string
    username: string
    Token?: TokenCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformCreateNestedManyWithoutUserInput
    rewards?: RewardCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    followedBy?: UserCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionHystoryInput = {
    id?: string
    email: string
    username: string
    Token?: TokenUncheckedCreateNestedManyWithoutUserInput
    password: string
    createdAt?: Date | string
    role?: Role
    updatedAt?: Date | string | null
    phoneNumber?: string | null
    firstName: string
    lastName: string
    recoveryPhase: string
    platforms?: PlatformUncheckedCreateNestedManyWithoutUserInput
    rewards?: RewardUncheckedCreateNestedManyWithoutUserInput
    slicesCollected?: number
    slicesPurchased?: number
    slicesSold?: number
    cakeBoxClaimed?: number
    totalRewardsEarned?: number
    avatar?: string | null
    sugar?: number
    followedBy?: UserUncheckedCreateNestedManyWithoutFollowingInput
    followedByIDs?: UserCreatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedCreateNestedManyWithoutFollowedByInput
    followingIDs?: UserCreatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionHystoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionHystoryInput, UserUncheckedCreateWithoutTransactionHystoryInput>
  }

  export type RewardUpsertWithoutTransactionHystoryInput = {
    update: XOR<RewardUpdateWithoutTransactionHystoryInput, RewardUncheckedUpdateWithoutTransactionHystoryInput>
    create: XOR<RewardCreateWithoutTransactionHystoryInput, RewardUncheckedCreateWithoutTransactionHystoryInput>
  }

  export type RewardUpdateWithoutTransactionHystoryInput = {
    User?: UserUpdateOneRequiredWithoutRewardsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    RewardBy?: RewardUpdateManyWithoutRewardNestedInput
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUpdateManyWithoutRewardByNestedInput
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RewardUncheckedUpdateWithoutTransactionHystoryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    RewardBy?: RewardUncheckedUpdateManyWithoutRewardNestedInput
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUncheckedUpdateManyWithoutRewardByNestedInput
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutTransactionHystoryInput = {
    update: XOR<UserUpdateWithoutTransactionHystoryInput, UserUncheckedUpdateWithoutTransactionHystoryInput>
    create: XOR<UserCreateWithoutTransactionHystoryInput, UserUncheckedCreateWithoutTransactionHystoryInput>
  }

  export type UserUpdateWithoutTransactionHystoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    followedBy?: UserUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionHystoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    followedBy?: UserUncheckedUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TokenCreateManyUserInput = {
    id?: string
    authToken: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isDisabled?: boolean
  }

  export type PlatformCreateManyUserInput = {
    id?: string
    link: string
    isPopular?: boolean | null
    title: string
  }

  export type RewardCreateManyUserInput = {
    id?: string
    name: string
    image: string
    smallImage: string
    cost: number
    rarity?: RarityEnum
    category: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    type: RewardEnum
    isCakeBox?: boolean
    isOnCakeBox?: boolean
    isConfectionary?: boolean
    RewardByIDs?: RewardCreateRewardByIDsInput | Enumerable<string>
    rewardIDs?: RewardCreaterewardIDsInput | Enumerable<string>
    initial?: boolean
  }

  export type TransactionHystoryCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    sliceId?: string | null
    amount?: number | null
    rewardId?: string | null
  }

  export type WalletCreateManyUserInput = {
    id?: string
    type: string
    name: string
    address: string
  }

  export type TokenUpdateWithoutUserInput = {
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenUncheckedUpdateWithoutUserInput = {
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenUncheckedUpdateManyWithoutTokenInput = {
    authToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformUpdateWithoutUserInput = {
    link?: StringFieldUpdateOperationsInput | string
    isPopular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformUncheckedUpdateWithoutUserInput = {
    link?: StringFieldUpdateOperationsInput | string
    isPopular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type PlatformUncheckedUpdateManyWithoutPlatformsInput = {
    link?: StringFieldUpdateOperationsInput | string
    isPopular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type RewardUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    TransactionHystory?: TransactionHystoryUpdateManyWithoutRewardNestedInput
    RewardBy?: RewardUpdateManyWithoutRewardNestedInput
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUpdateManyWithoutRewardByNestedInput
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RewardUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    TransactionHystory?: TransactionHystoryUncheckedUpdateManyWithoutRewardNestedInput
    RewardBy?: RewardUncheckedUpdateManyWithoutRewardNestedInput
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUncheckedUpdateManyWithoutRewardByNestedInput
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RewardUncheckedUpdateManyWithoutRewardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionHystoryUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sliceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    Reward?: RewardUpdateOneWithoutTransactionHystoryNestedInput
  }

  export type TransactionHystoryUncheckedUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sliceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionHystoryUncheckedUpdateManyWithoutTransactionHystoryInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sliceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutFollowingInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUpdateManyWithoutUserNestedInput
    followedBy?: UserUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: UserUncheckedUpdateManyWithoutFollowingNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutFollowedByInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
  }

  export type UserUpdateWithoutFollowedByInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUpdateManyWithoutUserNestedInput
    rewards?: RewardUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUpdateManyWithoutUserNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowedByInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    Token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    platforms?: PlatformUncheckedUpdateManyWithoutUserNestedInput
    rewards?: RewardUncheckedUpdateManyWithoutUserNestedInput
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    TransactionHystory?: TransactionHystoryUncheckedUpdateManyWithoutUserNestedInput
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    following?: UserUncheckedUpdateManyWithoutFollowedByNestedInput
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutFollowingInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    recoveryPhase?: StringFieldUpdateOperationsInput | string
    slicesCollected?: IntFieldUpdateOperationsInput | number
    slicesPurchased?: IntFieldUpdateOperationsInput | number
    slicesSold?: IntFieldUpdateOperationsInput | number
    cakeBoxClaimed?: IntFieldUpdateOperationsInput | number
    totalRewardsEarned?: IntFieldUpdateOperationsInput | number
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    sugar?: IntFieldUpdateOperationsInput | number
    followedByIDs?: UserUpdatefollowedByIDsInput | Enumerable<string>
    followingIDs?: UserUpdatefollowingIDsInput | Enumerable<string>
  }

  export type WalletUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type WalletUncheckedUpdateManyWithoutWalletsInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionHystoryCreateManyRewardInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    sliceId?: string | null
    amount?: number | null
  }

  export type TransactionHystoryUpdateWithoutRewardInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sliceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    User?: UserUpdateOneRequiredWithoutTransactionHystoryNestedInput
  }

  export type TransactionHystoryUncheckedUpdateWithoutRewardInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    sliceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RewardUpdateWithoutRewardInput = {
    User?: UserUpdateOneRequiredWithoutRewardsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    TransactionHystory?: TransactionHystoryUpdateManyWithoutRewardNestedInput
    RewardBy?: RewardUpdateManyWithoutRewardNestedInput
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RewardUncheckedUpdateWithoutRewardInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    TransactionHystory?: TransactionHystoryUncheckedUpdateManyWithoutRewardNestedInput
    RewardBy?: RewardUncheckedUpdateManyWithoutRewardNestedInput
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RewardUncheckedUpdateManyWithoutRewardByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RewardUpdateWithoutRewardByInput = {
    User?: UserUpdateOneRequiredWithoutRewardsNestedInput
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    TransactionHystory?: TransactionHystoryUpdateManyWithoutRewardNestedInput
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUpdateManyWithoutRewardByNestedInput
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RewardUncheckedUpdateWithoutRewardByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    TransactionHystory?: TransactionHystoryUncheckedUpdateManyWithoutRewardNestedInput
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    Reward?: RewardUncheckedUpdateManyWithoutRewardByNestedInput
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RewardUncheckedUpdateManyWithoutRewardInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    smallImage?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    rarity?: EnumRarityEnumFieldUpdateOperationsInput | RarityEnum
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumRewardEnumFieldUpdateOperationsInput | RewardEnum
    isCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isOnCakeBox?: BoolFieldUpdateOperationsInput | boolean
    isConfectionary?: BoolFieldUpdateOperationsInput | boolean
    RewardByIDs?: RewardUpdateRewardByIDsInput | Enumerable<string>
    rewardIDs?: RewardUpdaterewardIDsInput | Enumerable<string>
    initial?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}