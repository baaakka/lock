"use strict";
/**
 * Copyright 2020 Valentin Draganescu
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var metadata_storage_1 = require("../metadata/metadata-storage");
var logger_1 = require("../logger");
var validateIsRequired = function (propMeta, propertyValue, modelName, modelKey) {
    if (propMeta.isRequired && (propertyValue === undefined || propertyValue === null)) {
        // return `${modelName}.${modelKey} is required`;
        return modelKey + " is required";
    }
    return null;
};
var validateIsCorrectType = function (propType, propMeta, modelName, modelKey) {
    logger_1.Logger.log("Validating type", propType, propMeta, modelName, modelKey);
    if (propType === "number" || propType === "bigint") {
        if (propMeta.type !== "number" && propMeta.type !== "integer") {
            // return `${modelName}.${modelKey} should be of type ${propMeta.type}`;
            return modelKey + " should be of type " + propMeta.type;
        }
    }
    /*else if (propType === 'object' && Array.isArray(propMeta.objectType)) {
  
    }
      if (propType !== propMeta.type) {
        return `${modelName}.${modelKey} should be of type ${propMeta.type}`;
      }*/
    return null;
};
var validateMinSize = function (propMeta, propType, property, modelName, modelKey) {
    logger_1.Logger.log("validating minSize " + propMeta.minSize + " for propType " + propType);
    if (propMeta.minSize) {
        if (propType === "string" || propType === "object" || propType === "array") {
            logger_1.Logger.log("Length is " + property.length);
            if (property.length < propMeta.minSize) {
                // return `${modelName}.${modelKey} should have a minimum size of ${propMeta.minSize}`;
                return modelKey + " should have a minimum size of " + propMeta.minSize;
            }
        }
        if (propType === "number" || propType === "bigint") {
            if (property < propMeta.minSize) {
                // return `${modelName}.${modelKey} should be at least ${propMeta.minSize}`;
                return modelKey + " should be at least " + propMeta.minSize;
            }
        }
    }
    return null;
};
var validateFormat = function (propMeta, property, modelName, modelKey) {
    if (propMeta.format) {
        var regex = new RegExp(propMeta.format);
        var isCorrectFormat = regex.test(property);
        if (!isCorrectFormat) {
            // return `${modelName}.${modelKey} should have the format ${propMeta.format}`;
            return modelKey + " should have the format " + propMeta.format;
        }
    }
    return null;
};
var validateMaxSize = function (propMeta, propType, property, modelName, modelKey) {
    if (propMeta.maxSize) {
        if (propType === "string" || propType === "object" || propType === "array") {
            if (property.length > propMeta.maxSize) {
                // return `${modelName}.${modelKey} should have a maximum size of ${propMeta.maxSize}`;
                return modelKey + " should have a maximum size of " + propMeta.maxSize;
            }
        }
        if (propType === "number" || propType === "bigint") {
            if (property > propMeta.maxSize) {
                // return `${modelName}.${modelKey} should be at most ${propMeta.maxSize}`;
                return modelKey + " should be at most " + propMeta.maxSize;
            }
        }
    }
    return null;
};
var validateObject = function (propMeta, propertyValue) {
    var errors = [];
    if (propMeta.objectType) {
        errors.push.apply(errors, Validator.validate(propertyValue, propMeta.objectType));
    }
    else {
        var message = "No entity defined for object " + JSON.stringify(propertyValue);
        console.error(message);
        errors.push({ message: message });
    }
    return errors;
};
var validateRequiredProperties = function (property, propMeta, modelName, modelKey) {
    var errors = [];
    var error;
    var propType = typeof property;
    if (propType === "object" && Array.isArray(property)) {
        propType = "array";
    }
    var typeError = validateIsCorrectType(propType, propMeta, modelName, modelKey);
    if (typeError) {
        errors.push({ message: typeError });
    }
    if (!typeError) {
        error = validateMinSize(propMeta, propType, property, modelName, modelKey);
        if (error) {
            errors.push({ message: error });
        }
        error = validateMaxSize(propMeta, propType, property, modelName, modelKey);
        if (error) {
            errors.push({ message: error });
        }
        error = validateFormat(propMeta, property, modelName, modelKey);
        if (error) {
            errors.push({ message: error });
        }
    }
    return errors;
};
var baseTypes = ["string", "number"];
var Validator = /** @class */ (function () {
    function Validator() {
    }
    Validator.validate = function (body, objectType) {
        var modelNames;
        if (Array.isArray(objectType)) {
            modelNames = objectType;
        }
        else {
            modelNames = [objectType];
        }
        var errors = [];
        for (var _i = 0, modelNames_1 = modelNames; _i < modelNames_1.length; _i++) {
            var modelName = modelNames_1[_i];
            logger_1.Logger.log("Validating", modelName, JSON.stringify(body));
            var metadata = metadata_storage_1.getMetadataStorage();
            var entityMeta = metadata.entities[modelName];
            if (!entityMeta && !baseTypes.includes(modelName)) {
                var message = "Entity " + modelName + " is not registered with the router";
                console.error(message);
                errors.push({ message: message });
            }
            if (entityMeta && (body === null || body === undefined)) {
                if (entityMeta) {
                    logger_1.Logger.log('entity metadata', JSON.stringify(entityMeta));
                    errors.push({
                        message: modelName + " is required"
                    });
                    return errors;
                }
            }
            if (Array.isArray(body)) {
                for (var _a = 0, body_1 = body; _a < body_1.length; _a++) {
                    var item = body_1[_a];
                    errors.push.apply(errors, Validator.validate(item, modelName));
                }
            }
            else {
                if (typeof body === "object" && entityMeta !== undefined) {
                    try {
                        var modelKeys = Object.keys(entityMeta);
                        for (var _b = 0, modelKeys_1 = modelKeys; _b < modelKeys_1.length; _b++) {
                            var modelKey = modelKeys_1[_b];
                            var propMeta = entityMeta[modelKey];
                            var propertyValue = body[modelKey];
                            logger_1.Logger.log("Validating " + modelName + "." + modelKey);
                            if (typeof propertyValue === "object" && propertyValue !== null) {
                                logger_1.Logger.log("Property is an object");
                                errors.push.apply(errors, validateRequiredProperties(propertyValue, propMeta, modelName, modelKey));
                                errors.push.apply(errors, validateObject(propMeta, propertyValue));
                            }
                            else {
                                logger_1.Logger.log("Property is a primitive with value", propertyValue);
                                logger_1.Logger.log("Validating with propMeta", propMeta);
                                if (propMeta) {
                                    var error = validateIsRequired(propMeta, propertyValue, modelName, modelKey);
                                    if (error) {
                                        errors.push({ message: error });
                                    }
                                    if (propertyValue !== undefined && propertyValue !== null) {
                                        errors.push.apply(errors, validateRequiredProperties(propertyValue, propMeta, modelName, modelKey));
                                    }
                                    if (propMeta.enum && propMeta.isRequired && !propMeta.enum.includes(propertyValue)) {
                                        errors.push({
                                            message: "The property " + modelKey + " value must be one of [" + propMeta.enum.join(',') + "], " + propertyValue + " was provided instead"
                                        });
                                    }
                                }
                            }
                        }
                    }
                    catch (err) {
                        logger_1.Logger.log("validation failed", err);
                        logger_1.Logger.log("body", body, objectType, entityMeta, modelName);
                    }
                }
            }
        }
        return errors;
    };
    return Validator;
}());
exports.Validator = Validator;
//# sourceMappingURL=validator.js.map