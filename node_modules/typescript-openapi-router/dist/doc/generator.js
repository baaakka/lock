"use strict";
/**
 * Copyright 2020 Valentin Draganescu
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var api_1 = require("./model/api");
var metadata_storage_1 = require("../metadata/metadata-storage");
var paths_1 = require("./model/paths");
var logger_1 = require("../logger");
var getResponseContent = function (response) {
    var _a;
    var _b, _c, _d, _e;
    logger_1.Logger.log("resolving response content for", response.description);
    // object schema
    var contentType = (_b = response.contentType, (_b !== null && _b !== void 0 ? _b : "application/json"));
    var docContent = {};
    if ((_c = response.body) === null || _c === void 0 ? void 0 : _c.name) {
        docContent[contentType] = {
            schema: {
                $ref: "#/components/schemas/" + ((_d = response.body) === null || _d === void 0 ? void 0 : _d.name),
            },
            example: response.example,
        };
    }
    if (response.schema) {
        docContent[contentType] = {
            schema: response.schema,
        };
    }
    // array schema
    if (response.type === "array") {
        docContent = (_a = {},
            _a[contentType] = {
                schema: {
                    type: "array",
                    items: {
                        $ref: "#/components/schemas/" + ((_e = response.body) === null || _e === void 0 ? void 0 : _e.name),
                    },
                },
                example: response.example,
            },
            _a);
        if (response.schema) {
            docContent[contentType].schema = response.schema;
        }
    }
    return docContent;
};
var resolveResponses = function (routeMetadata) {
    var responses = {};
    for (var _i = 0, _a = routeMetadata.responses; _i < _a.length; _i++) {
        var response = _a[_i];
        responses[String(response.statusCode)] = {
            description: response.description,
        };
        responses[String(response.statusCode)].content = getResponseContent(response);
    }
    return responses;
};
var generatePathDoc = function (apiDoc, metadata) {
    var _a;
    var _b, _c, _d, _e, _f;
    var thisDoc = __assign({}, apiDoc);
    var paths = metadata.getPaths();
    thisDoc.paths = {};
    for (var _i = 0, paths_2 = paths; _i < paths_2.length; _i++) {
        var path = paths_2[_i];
        if (!thisDoc.paths[path]) {
            thisDoc.paths[path] = new paths_1.DocPath();
        }
        var methodMetadata = metadata.paths.get(path);
        if (methodMetadata) {
            var methods = Object.keys(methodMetadata);
            for (var _g = 0, methods_1 = methods; _g < methods_1.length; _g++) {
                var method = methods_1[_g];
                var loweredMethod = method.toLowerCase();
                if (!thisDoc.paths[path][loweredMethod]) {
                    var routeMetadata = methodMetadata[method];
                    thisDoc.paths[path][loweredMethod] = {
                        tags: routeMetadata.tags,
                        description: routeMetadata.description,
                        summary: routeMetadata.summary,
                        operationId: method + "-" + path,
                        security: (_b = routeMetadata.security, (_b !== null && _b !== void 0 ? _b : (_c = metadata.docMetadata) === null || _c === void 0 ? void 0 : _c.security)),
                    };
                    if (routeMetadata.responses) {
                        thisDoc.paths[path][loweredMethod].responses = resolveResponses(routeMetadata);
                        if ((_d = metadata.docMetadata) === null || _d === void 0 ? void 0 : _d.globalResponses) {
                            for (var _h = 0, _j = metadata.docMetadata.globalResponses; _h < _j.length; _h++) {
                                var globalResponse = _j[_h];
                                if (!thisDoc.paths[path][loweredMethod].responses[globalResponse.statusCode]) {
                                    thisDoc.paths[path][loweredMethod].responses[globalResponse.statusCode] = {
                                        description: globalResponse.description,
                                        content: getResponseContent(globalResponse),
                                    };
                                }
                            }
                        }
                    }
                    if (routeMetadata.requestBody) {
                        var contentTypeHeader = (_e = routeMetadata.parameters) === null || _e === void 0 ? void 0 : _e.filter(function (param) { return param.in === "header" && param.name.toLowerCase() === "content-type"; });
                        thisDoc.paths[path][loweredMethod].requestBody = {
                            content: (_a = {},
                                _a[(contentTypeHeader && contentTypeHeader.length) ? contentTypeHeader[0].default : "application/json"] = {
                                    schema: {
                                        $ref: "#/components/schemas/" + ((_f = routeMetadata.requestBody) === null || _f === void 0 ? void 0 : _f.name),
                                    },
                                    example: routeMetadata.example,
                                },
                                _a),
                        };
                    }
                    if (routeMetadata.parameters) {
                        thisDoc.paths[path][loweredMethod].parameters = routeMetadata.parameters;
                    }
                }
            }
        }
    }
    return thisDoc;
};
var primitiveTypes = ["string", "number", "integer", "boolean"];
var resolvePropertyDocumentation = function (propMeta) {
    if (propMeta.type === "object") {
        if (Array.isArray(propMeta.objectType)) {
            var objectModel = {
                oneOf: [],
            };
            for (var _i = 0, _a = propMeta.objectType; _i < _a.length; _i++) {
                var type = _a[_i];
                console.log("Adding type", type);
                if (primitiveTypes.includes(type)) {
                    objectModel.oneOf.push({
                        type: type,
                    });
                    continue;
                }
                objectModel.oneOf.push({
                    $ref: "#/components/schemas/" + type,
                });
            }
            return objectModel;
        }
        return {
            $ref: "#/components/schemas/" + propMeta.objectType,
        };
    }
    var model = {
        type: propMeta.type,
        nullable: propMeta.nullable,
        description: propMeta.description,
        format: propMeta.format,
        enum: propMeta.enum,
        default: propMeta.default,
    };
    if (propMeta.type === "string") {
        model.minLength = propMeta.minSize;
        model.maxLength = propMeta.maxSize;
    }
    if (propMeta.type === "number" || propMeta.type === "integer") {
        model.minimum = propMeta.minSize;
        model.maximum = propMeta.maxSize;
    }
    if (propMeta.type === "array") {
        model.minItems = propMeta.minSize;
        model.maxItems = propMeta.maxSize;
        if (propMeta.objectType) {
            if (Array.isArray(propMeta.objectType)) {
                if (!model.items) {
                    model.items = {};
                }
                model.items.oneOf = [];
                for (var _b = 0, _c = propMeta.objectType; _b < _c.length; _b++) {
                    var type = _c[_b];
                    console.log("generating for type", type);
                    if (primitiveTypes.includes(type)) {
                        model.items.oneOf.push({
                            type: type,
                        });
                    }
                    else {
                        model.items.oneOf.push({
                            $ref: "#/components/schemas/" + type,
                        });
                    }
                }
            }
            else {
                if (primitiveTypes.includes(propMeta.objectType)) {
                    model.items = {
                        type: propMeta.objectType,
                    };
                }
                else {
                    model.items = {
                        $ref: "#/components/schemas/" + propMeta.objectType,
                    };
                }
            }
        }
    }
    return model;
};
var resolveModelDocumentation = function (propKeys, metadata, entityName) {
    var properties = {};
    var required = [];
    for (var _i = 0, propKeys_1 = propKeys; _i < propKeys_1.length; _i++) {
        var propKey = propKeys_1[_i];
        var propMeta = metadata.entities[entityName][propKey];
        if (!propMeta) {
            console.error("No prop meta found for entity", propKey);
            continue;
        }
        properties[propKey] = resolvePropertyDocumentation(propMeta);
        if (propMeta.isRequired) {
            required.push(propKey);
        }
    }
    return [properties, required];
};
exports.generateDoc = function (version) {
    var _a, _b, _c;
    var metadata = metadata_storage_1.getMetadataStorage();
    var apiDoc = new api_1.DocApi();
    apiDoc.openapi = version;
    if (metadata.docMetadata) {
        var info = __assign({}, metadata.docMetadata);
        delete info.securitySchemes;
        delete info.security;
        delete info.servers;
        delete info.additionalRouters;
        delete info.globalResponses;
        delete info.globalMiddleware;
        apiDoc.info = info;
    }
    var schemas = {};
    var metadataEntities = Object.keys(metadata.entities);
    for (var _i = 0, metadataEntities_1 = metadataEntities; _i < metadataEntities_1.length; _i++) {
        var entityName = metadataEntities_1[_i];
        var propKeys = Object.keys(metadata.entities[entityName]);
        var _d = resolveModelDocumentation(propKeys, metadata, entityName), properties = _d[0], required = _d[1];
        schemas[entityName] = {
            properties: properties,
        };
        if (required.length) {
            schemas[entityName].required = required;
        }
    }
    apiDoc.components = {
        schemas: schemas,
    };
    if ((_a = metadata.docMetadata) === null || _a === void 0 ? void 0 : _a.securitySchemes) {
        apiDoc.components.securitySchemes = metadata.docMetadata.securitySchemes;
    }
    if (metadata.paths && metadata.paths.size) {
        apiDoc = generatePathDoc(apiDoc, metadata);
    }
    if ((_b = metadata.docMetadata) === null || _b === void 0 ? void 0 : _b.security) {
        apiDoc.security = metadata.docMetadata.security;
    }
    if ((_c = metadata.docMetadata) === null || _c === void 0 ? void 0 : _c.servers) {
        apiDoc.servers = metadata.docMetadata.servers;
    }
    return apiDoc;
};
//# sourceMappingURL=generator.js.map